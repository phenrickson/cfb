---
title: "model_sequences"
author: "Phil Henrickson"
date: "6/7/2022"
output: 
  html_document:
    toc: TRUE #adds a Table of Contents
    theme: cerulean
    number_sections: TRUE #number your headings/sections
    toc_float: TRUE #let your ToC follow you as you scroll
    keep_md: no
    fig.caption: yes
    css: "styles.css"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = F,
                      error = F,
                      warning=F,
                      dev="png",
                      fig.width = 10,
                      fig.height = 6)

options(knitr.duplicate.label = "allow")

options(scipen=999)

```


```{r connect to snowflake}

library(DBI)
library(odbc)
library(RODBC)
library(keyring)

# connect to snowflake
myconn <- DBI::dbConnect(odbc::odbc(),
                         "SnowflakeDSII",
                         Database = "CFB_DEMO",
                         warehouse = "DEMO_WH",
                         uid="phil.henrickson",
                         pwd=keyring::key_get("AE_Snowflake"))

```

```{r packages, include=F} 

source(here::here("scripts/load_packages.R"))
library(jsonlite)
library(forcats)
conflict_prefer("lag", "dplyr")

```

```{r load functions}

source(here::here("functions/theme_phil.R"))
source(here::here("functions/clean_plays_func.R"))
source(here::here("functions/make_time_features_func.R"))
source(here::here("functions/plot_scoreline_func.R"))
rm(a)
```

```{r query data from snowflake}

### pull from snowflake
# get plays
plays_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.PLAY_BY_PLAY')) %>%
        as_tibble() %>%
        mutate(TIME = gsub('\\{|}|"', '', CLOCK)) %>%
        separate(TIME, into=c("MINUTES", "SECONDS"), sep=",") %>%
        mutate(MINUTES = as.numeric(gsub("minutes:", "", MINUTES))) %>% 
        mutate(SECONDS = as.numeric(gsub("seconds:", "", SECONDS))) %>%
        mutate(MINUTES_IN_HALF = case_when(PERIOD == 1 ~ MINUTES+ 15,
                                           PERIOD == 2 ~ MINUTES,
                                           PERIOD == 3 ~ MINUTES + 15,
                                           PERIOD == 4 ~ MINUTES)) %>%
        mutate(SECONDS_IN_HALF = MINUTES_IN_HALF*60 + SECONDS) %>%
        # flag if seconds in half is invalid
        mutate(FLAG_SECONDS_IN_HALF = case_when(SECONDS_IN_HALF > 1800 ~ 1,
                                                TRUE ~ 0)) %>%
        # convert IDs to numeric
        mutate(ID = as.numeric(ID),
               DRIVE_ID = as.numeric(DRIVE_ID)) %>%
        rename(PLAY_ID = ID) %>%
        group_by(GAME_ID) %>%
        # sort each game by drive
        arrange(PLAY_ID) %>% 
        ungroup() %>%
        # clean up PERIOD by game
        mutate(STATUS_PERIOD = case_when(PERIOD == 0 & nchar(PLAY_TEXT) <=1 ~ 'Drop',
                                        PERIOD == 0 ~ 'Take Previous Value',
                                        TRUE ~ 'Valid')) %>%
        filter(STATUS_PERIOD != 'Drop') %>%
        mutate(PERIOD = case_when(STATUS_PERIOD == 'Take Previous Value' ~ lag(PERIOD, 1),
                                  TRUE ~ PERIOD)) %>%
        ungroup() %>% 
        mutate(HALF = case_when(PERIOD == 1 ~ 'First Half',
                                PERIOD == 2 ~ 'First Half',
                                PERIOD == 3 ~ 'Second Half',
                                PERIOD == 4 ~ 'Second Half',
                                TRUE ~ 'OT')) %>%
        # then clean up the down
        mutate(FLAG_DOWN = case_when(DOWN %in% c(1, 2, 3, 4) ~ 0,
                                       TRUE ~ 1)) %>%
        mutate(DOWN = case_when(DOWN %in% c(1, 2, 3, 4) ~ DOWN,
                                TRUE ~ -1)) %>%
        # then flag the distance
        mutate(FLAG_DISTANCE = case_when((DISTANCE < 0 | DISTANCE >=99) ~ 1,
                                         TRUE ~ 0)) %>%
        # flag yard lines that are outside correct
        mutate(FLAG_YARD_LINE = case_when(YARD_LINE < 0 | YARD_LINE > 100 ~ 1,
                                          TRUE ~ 0))

# get games
games_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.GAMES')) %>%
        as_tibble() %>%
        mutate(ID = as.numeric(ID)) %>%
        rename(GAME_ID = ID)
        
# get drives
drives_data_raw = DBI::dbGetQuery(myconn,
                              paste('SELECT * FROM CFB_DEMO.CFD_RAW.DRIVES')) %>%
        as_tibble() %>%
        mutate(ID = as.numeric(ID),
               GAME_ID = as.numeric(GAME_ID)) %>%
        rename(DRIVE_ID = ID) %>%
        # get drive time features
        # start of drive
        mutate(START_TIME = gsub('\\{|}|"', '', START_TIME)) %>%
        separate(START_TIME, into=c("START_MINUTES", "START_SECONDS"), sep=",") %>%
        mutate(START_MINUTES = as.numeric(gsub("minutes:", "", START_MINUTES))) %>% 
        mutate(START_SECONDS = as.numeric(gsub("seconds:", "", START_SECONDS))) %>%
        # end of drive
        mutate(END_TIME = gsub('\\{|}|"', '', END_TIME)) %>%
        separate(END_TIME, into=c("END_MINUTES", "END_SECONDS"), sep=",") %>%
        mutate(END_MINUTES = as.numeric(gsub("minutes:", "", END_MINUTES))) %>% 
        mutate(END_SECONDS = as.numeric(gsub("seconds:", "", END_SECONDS))) %>%
        # duration of drive
        mutate(ELAPSED = gsub('\\{|}|"', '', ELAPSED)) %>%
        separate(ELAPSED, into=c("ELAPSED_MINUTES", "ELAPSED_SECONDS"), sep=",") %>%
        mutate(ELAPSED_MINUTES = as.numeric(gsub("minutes:", "", ELAPSED_MINUTES))) %>% 
        mutate(ELAPSED_SECONDS = as.numeric(gsub("seconds:", "", ELAPSED_SECONDS))) 
        
```

```{r apply clean up functions}

# now get scoring events for the drives data
drives_data_score_events = drives_data_raw %>%
        group_by(GAME_ID) %>%
        arrange(DRIVE_ID) %>%
        mutate(HALF = case_when(START_PERIOD == 1 | START_PERIOD == 2 ~ 'First Half',
                                START_PERIOD == 3 | START_PERIOD == 4 ~ 'Second Half',
                                TRUE ~ 'OT')) %>%
        mutate(HOME = case_when(IS_HOME_OFFENSE == T ~ OFFENSE,
                                IS_HOME_OFFENSE ==F ~ DEFENSE),
               AWAY = case_when(IS_HOME_OFFENSE == T  ~ DEFENSE,
                                IS_HOME_OFFENSE ==F ~ OFFENSE)) %>%
        mutate(END_HOME_SCORE = case_when(IS_HOME_OFFENSE == T ~ END_OFFENSE_SCORE,
                                          IS_HOME_OFFENSE == F ~ END_DEFENSE_SCORE),
               END_AWAY_SCORE = case_when(IS_HOME_OFFENSE == F ~ END_OFFENSE_SCORE,
                                          IS_HOME_OFFENSE == T ~ END_DEFENSE_SCORE)) %>%
        group_by(GAME_ID, HALF) %>%
        mutate(LAST_DRIVE_HALF = case_when(DRIVE_NUMBER == max(DRIVE_NUMBER) ~ T,
                                           TRUE ~ F)) %>%
        ungroup() %>%
        group_by(GAME_ID) %>%
        mutate(HOME_SCORE_DIFF = END_HOME_SCORE - lag(END_HOME_SCORE, 1, default=0),
               AWAY_SCORE_DIFF = END_AWAY_SCORE - lag(END_AWAY_SCORE, 1, default=0)) %>%
        mutate(MULTIPLE_SCORE_CHANGES = HOME_SCORE_DIFF & AWAY_SCORE_DIFF > 0) %>%
        mutate(PROBLEM_AWAY_CHANGE = grepl("rush td|pass td|rushing td|passing td|fg good", tolower(DRIVE_RESULT)) & IS_HOME_OFFENSE == T & AWAY_SCORE_DIFF > 0,
               PROBLEM_HOME_CHANGE = grepl("rush td|pass td|rushing td|passing td|fg good", tolower(DRIVE_RESULT)) & IS_HOME_OFFENSE == F & HOME_SCORE_DIFF > 0) %>%
        mutate(SCORE_EVENT = case_when((tolower(DRIVE_RESULT) == 'td' | grepl("rush td|pass td|rushing td|passing td", tolower(DRIVE_RESULT))) & IS_HOME_OFFENSE == T ~ 'HOME TD',
                                       (tolower(DRIVE_RESULT) == 'td' | grepl("rush td|pass td|rushing td|passing td", tolower(DRIVE_RESULT))) & IS_HOME_OFFENSE == F ~ 'AWAY TD',
                                       grepl("rush td|pass td|rushing td|passing td", tolower(DRIVE_RESULT)) & IS_HOME_OFFENSE == T ~ 'HOME TD',
                                       grepl("rush td|pass td|rushing td|passing td", tolower(DRIVE_RESULT)) & IS_HOME_OFFENSE == F ~ 'AWAY TD',
                                       grepl("kickoff return td|kickoff td|kick return td|punt return td", tolower(DRIVE_RESULT)) & IS_HOME_OFFENSE ==T ~ 'AWAY TD',
                                       grepl("kickoff return td|kickoff td|kick return td|punt return td", tolower(DRIVE_RESULT)) & IS_HOME_OFFENSE ==F ~ 'HOME TD',
                                       (tolower(DRIVE_RESULT) == 'fg' | grepl("made fg|fg good", tolower(DRIVE_RESULT))) & IS_HOME_OFFENSE == T ~ 'HOME FG',
                                       (tolower(DRIVE_RESULT) == 'fg' | grepl("made fg|fg good", tolower(DRIVE_RESULT))) & IS_HOME_OFFENSE == F ~ 'AWAY FG',
                                       HOME_SCORE_DIFF == 6 | HOME_SCORE_DIFF == 7 | HOME_SCORE_DIFF == 8 ~ 'HOME TD',
                                       HOME_SCORE_DIFF == 3 ~ 'HOME FG',
                                       HOME_SCORE_DIFF == 2 ~ 'HOME Safety',
                                       AWAY_SCORE_DIFF == 6 | AWAY_SCORE_DIFF == 7 | AWAY_SCORE_DIFF == 8 ~ 'AWAY TD',
                                       AWAY_SCORE_DIFF == 3 ~ 'AWAY FG',
                                       AWAY_SCORE_DIFF == 2 ~ 'AWAY Safety', 
                                       (HOME_SCORE_DIFF == 0 & AWAY_SCORE_DIFF == 0) & LAST_DRIVE_HALF == T ~ 'No_Score')) %>%
        mutate(MISSING_SCORING_EVENT = SCORING == T & is.na(SCORE_EVENT)) %>%
        #  filter(MISSING_SCORING_EVENT == T) %>%
        mutate(NEXT_SCORE_EVENT = SCORE_EVENT) %>%
        # this fills in previous drives with no scoring event with the next observed scoring event in a half
        fill(NEXT_SCORE_EVENT, .direction = "up") %>%
        ungroup() 

```

```{r now join this with plays}

# now join with plays
plays_data_score_events = plays_data_raw %>%
        left_join(.,
                  drives_data_score_events %>%
                          select(GAME_ID,
                                 DRIVE_ID,
                                 HOME, 
                                 AWAY,
                                 LAST_DRIVE_HALF,
                                 END_HOME_SCORE,
                                 END_AWAY_SCORE,
                                 SCORE_EVENT,
                                 NEXT_SCORE_EVENT),
                  by = c("GAME_ID",
                         "DRIVE_ID",
                         "HOME", 
                         "AWAY")) %>%
        # now join with games to get seasons
        left_join(.,
                  games_data_raw %>%
                          select(GAME_ID,
                                 SEASON,
                                 HOME_TEAM,
                                 AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        rename(NEXT_SCORE_EVENT_HOME = NEXT_SCORE_EVENT) %>%
        mutate(NEXT_SCORE_EVENT_OFFENSE = case_when(OFFENSE == HOME & NEXT_SCORE_EVENT_HOME == 'HOME TD' ~ 'TD',
                                                    OFFENSE == HOME & NEXT_SCORE_EVENT_HOME == 'AWAY TD' ~ 'Opp_TD',
                                                    OFFENSE == HOME & NEXT_SCORE_EVENT_HOME == 'HOME FG' ~ 'FG',
                                                    OFFENSE == HOME & NEXT_SCORE_EVENT_HOME == 'AWAY FG' ~ 'Opp_FG',
                                                    OFFENSE == HOME & NEXT_SCORE_EVENT_HOME == 'HOME Safety' ~ 'Safety',
                                                    OFFENSE == HOME & NEXT_SCORE_EVENT_HOME == 'AWAY Safety' ~ 'Opp_Safety',
                                                    OFFENSE == AWAY & NEXT_SCORE_EVENT_HOME == 'HOME TD' ~ 'Opp_TD',
                                                    OFFENSE == AWAY & NEXT_SCORE_EVENT_HOME == 'AWAY TD' ~ 'TD',
                                                    OFFENSE == AWAY & NEXT_SCORE_EVENT_HOME == 'HOME FG' ~ 'Opp_FG',
                                                    OFFENSE == AWAY & NEXT_SCORE_EVENT_HOME == 'AWAY FG' ~ 'FG',
                                                    OFFENSE == AWAY & NEXT_SCORE_EVENT_HOME == 'HOME Safety' ~ 'Opp_Safety',
                                                    OFFENSE == AWAY & NEXT_SCORE_EVENT_HOME == 'AWAY Safety' ~ 'Safety',
                                                    NEXT_SCORE_EVENT_HOME == 'No_Score' ~ 'No_Score')) %>%
        mutate(NEXT_SCORE_EVENT_HOME_DIFF = case_when(NEXT_SCORE_EVENT_HOME == 'HOME TD' ~ 7,
                                              NEXT_SCORE_EVENT_HOME == 'HOME FG' ~ 3,
                                              NEXT_SCORE_EVENT_HOME == 'HOME Safety' ~ 2,
                                              NEXT_SCORE_EVENT_HOME == 'No_Score' ~ 0,
                                              NEXT_SCORE_EVENT_HOME == 'HOME Safety' ~ -2,
                                              NEXT_SCORE_EVENT_HOME == 'HOME FG' ~ -3,
                                              NEXT_SCORE_EVENT_HOME == 'HOME TD' ~ -7)) %>%
        mutate(NEXT_SCORE_EVENT_OFFENSE_DIFF = case_when(NEXT_SCORE_EVENT_OFFENSE == 'TD' ~ 7,
                                              NEXT_SCORE_EVENT_OFFENSE == 'FG' ~ 3,
                                              NEXT_SCORE_EVENT_OFFENSE == 'Safety' ~ 2,
                                              NEXT_SCORE_EVENT_OFFENSE == 'No_Score' ~ 0,
                                              NEXT_SCORE_EVENT_OFFENSE == 'Opp_Safety' ~ -2,
                                              NEXT_SCORE_EVENT_OFFENSE == 'Opp_FG' ~ -3,
                                              NEXT_SCORE_EVENT_OFFENSE == 'Opp_TD' ~ -7)) %>%
        mutate(NEXT_SCORE_EVENT_OFFENSE = factor(NEXT_SCORE_EVENT_OFFENSE,
                                                     levels = c("TD",
                                                                "FG",
                                                                "Safety",
                                                                "No_Score",
                                                                "Opp_Safety",
                                                                "Opp_FG",
                                                                "Opp_TD")))
                                                 
```

# What is this? {-}

# Exploring The Data

The data used is from college football games from 2000 to present. Each observation represents one play in a game, in which we know the team, the situation (down, time remaining), and the location on the field (yards to go, yards to reach end zone). We have information about the types of plays called as well in a text field.

```{r show skimr}

plays_data_score_events %>%
        filter(SEASON < 2015) %>%
        mutate_at(vars(contains("_ID")),
                  ~ as.character(.)) %>%
        sample_n(1000) %>%
        skimr::skim_without_charts(.)

```

The goal of this analysis is to determine the value of individual plays in terms of expected points. 

A sequence in this case is defined as all plays within a half between kickoffs (either the beginning or scoring events). Every sequence can end in one of 7 different outcomes, which we will define from the perspective of the team on offense. If a team has the ball, for any play, there are seven possible outcomes that play will eventually reach:

* Touchdown (7 points)
* Field goal (3 points)
* Safety (2 points)
* No_Score (0 points)
* Opp_Safety (2 points)
* Opp field goal (-3 points)
* Opp touchdown (-7 points)

For instance, on drive 1, Team A receives the opening kickoff, drives for a few plays, and then punts. Team B takes over, which starts drive 2, and they drive for a few plays before also punting. Team A then manages to put together a drive that finally scores. All plays on these three drives are one sequence. The outcome of this sequence is the points scored by Team A - if they score a toucbhdown, their points from this sequence is 7 (assuming they make the extra point). Team B's points from this sequence is -7 points.

When Team A kicks off to Team B to start drive 4, we start our next sequence, which will end either with one team scoring or at the end of the half. We'll then start over with a new sequence in the second half.

The outcome for this analysis is the NEXT_SCORE_EVENT. Each play in a given sequence contributes to the eventual outcome of the sequence. Here we can see an example of one game and its drives.

```{r show a full game of sequences}

drives_data_score_events %>%
        left_join(.,
                  games_data_raw %>%
                          select(GAME_ID,
                                 SEASON,
                                 HOME_TEAM,
                                 AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        filter(HOME_TEAM == 'Texas A&M' & AWAY_TEAM == 'Florida') %>%
        filter(SEASON == 2012) %>%
        select(SEASON, HOME, AWAY, HALF, DRIVE_NUMBER, END_HOME_SCORE, END_AWAY_SCORE, NEXT_SCORE_EVENT) %>%
        mutate(SEASON = as.character(SEASON)) %>%
        flextable() %>%
        autofit()
        
```

For this game, we can filter to the plays that took place in the lead up to first score event. In this case, the first sequence included one drive and ended when Texas A&M kicked a field goal.

```{r zoom in on a sequence}

plays_data_score_events %>%
        filter(HOME_TEAM == 'Texas A&M' & AWAY_TEAM == 'Florida') %>%
        filter(SEASON == 2012) %>%
        filter(DRIVE_NUMBER == 1) %>%
        select(SEASON, OFFENSE, DEFENSE, DRIVE_NUMBER,  PLAY_NUMBER, DOWN, DISTANCE, YARDS_TO_GOAL, PLAY_TEXT, NEXT_SCORE_EVENT_OFFENSE) %>%
        mutate(SEASON = as.character(SEASON)) %>%
        flextable() %>%
        autofit()
        
```

If we look at another sequence in the second half, there were multiple drives before a team was able to score.

```{r zoom in on another sequence}

plays_data_score_events %>%
        filter(HOME_TEAM == 'Texas A&M' & AWAY_TEAM == 'Florida') %>%
        filter(SEASON == 2012) %>%
        filter(DRIVE_NUMBER>=9 & DRIVE_NUMBER <=14) %>%
        select(SEASON, OFFENSE, DEFENSE, HALF, DRIVE_NUMBER,  PLAY_NUMBER, DOWN, DISTANCE, YARDS_TO_GOAL, PLAY_TEXT, NEXT_SCORE_EVENT_OFFENSE) %>%
        mutate(SEASON = as.character(SEASON)) %>%
        flextable() %>%
        autofit()
```

Our goal is to understand how individual plays contribute to a team's **expected points**, or the average points teams should expect to have given their situation (down, time, possession). 

For instance, in the first drive of this game, Texas A&M received the ball at their own 25 yard line - the simplest intuition of expected points is to ask, for teams starting at the 25 yard line at the beginning of a game, how many points do they typically go on to score? The answer is to look at all starting drives with 75 yards to go and see what happened - we take the average of all of the points that followed from this situation.

```{r expected points given situation}

plays_data_score_events %>%
        filter(SEASON >=2010) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(!grepl("kick", tolower(PLAY_TEXT))) %>%
        filter(YARDS_TO_GOAL == 75 & DRIVE_NUMBER ==1) %>%
        group_by(NEXT_SCORE_EVENT_OFFENSE) %>%
        count(sort=T)

plays_data_score_events %>%
        filter(SEASON >=2010) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(YARDS_TO_GOAL == 75 & DRIVE_NUMBER ==1) %>%
        group_by(YARDS_TO_GOAL, DRIVE_NUMBER) %>%
        summarize(expected_points = mean(NEXT_SCORE_EVENT_OFFENSE_DIFF),
                  n = n(),
                  .groups = 'drop') %>%
        mutate_if(is.numeric, round, 2)

```

In this case, this means teams with the ball at their own 25 to start the game generally obtained more points on the ensuing sequence than their opponents, so they have a slightly positive expected points.

But, this is also a function of the down. If we look at the expected points for a team in this situation in first down vs a team in this situation for fourth down, we should see a drop in their expected points - by the time you hit fourth down, if you haven't moved from the 25, your expected points drops into the negatives, as you will now be punting the ball back to your opponent and it becomes more probable that they score than you.

```{r how does this vary as a function of }

plays_data_score_events %>%
        filter(SEASON >= 2010) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(YARDS_TO_GOAL == 75  & DRIVE_NUMBER ==1) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        group_by(YARDS_TO_GOAL, DOWN, NEXT_SCORE_EVENT_OFFENSE) %>%
        count() %>%
        spread(DOWN, n) %>%
        arrange(NEXT_SCORE_EVENT_OFFENSE) %>%
        arrange(desc(`4`))

plays_data_score_events %>%
        filter(SEASON >= 2010) %>%
        filter(YARDS_TO_GOAL == 75  & DRIVE_NUMBER ==1) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        group_by(YARDS_TO_GOAL, DOWN) %>%
        summarize(expected_points = mean(NEXT_SCORE_EVENT_OFFENSE_DIFF, na.rm=T),
                  n = n(),
                  .groups = 'drop') %>%
        mutate_if(is.numeric, round, 2)

```

We can apply this type of thinking to the entire field. If we look at all total plays in a game, how do expected points vary as a function of a team's distance from their opponent's goal line?

```{r expected points as a function of yard line for opening}

plays_data_score_events %>%
        filter(SEASON >= 2010) %>%
        filter(!grepl("kick", tolower(PLAY_TYPE))) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(YARD_LINE < 100 & YARD_LINE > 0) %>%
      #  mutate(YARD_LINE_5 = plyr::round_any(YARDS_TO_GOAL, 5, floor)) %>%
     #   group_by(YARDS_TO_GOAL) %>%
        group_by(YARDS_TO_GOAL) %>%
        summarize(expected_points = mean(NEXT_SCORE_EVENT_OFFENSE_DIFF, na.rm=T),
                  n = n()) %>%
        ggplot(., aes(x=YARDS_TO_GOAL,
                      y=expected_points))+
        geom_line()+
        geom_point(aes(size=n))+
        theme_phil()+
        geom_hline(yintercept = 0,
                   linetype = 'dotted')+
        scale_x_reverse()

```

```{r look at outcomes by yards to goal}

plays_data_score_events %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(YARD_LINE < 100 & YARD_LINE > 0) %>%
      #  mutate(YARD_LINE_5 = plyr::round_any(YARDS_TO_GOAL, 5, floor)) %>%
     #   group_by(YARDS_TO_GOAL) %>%
        group_by(YARDS_TO_GOAL, NEXT_SCORE_EVENT_OFFENSE) %>%
        count() %>%
        ggplot(., aes(x=YARDS_TO_GOAL,
                      fill = NEXT_SCORE_EVENT_OFFENSE,
                      y=n))+
        geom_col(position = 'fill')+
        scale_fill_viridis_d(option = 'B')+
        theme_phil()+
        scale_x_reverse()

```

This should make sense - if you're backed up against your own end zone, your opponent becomes more likely to have the next scoring event, either by gaining good field advantage after you punt or by getting a safety.

But, it's not just position on the field - it's also about the situation. If we look at how expected points varies by the down, we should see that fourth downs always have lower expected points.

```{r look at expected points by down and field position}

plays_data_score_events %>%
        filter(PLAY_TYPE != 'Timeout') %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(YARD_LINE < 100 & YARD_LINE > 0) %>%
      #  mutate(YARD_LINE_5 = plyr::round_any(YARDS_TO_GOAL, 5, floor)) %>%
     #   group_by(YARDS_TO_GOAL) %>%
        group_by(YARDS_TO_GOAL, DOWN) %>%
        summarize(expected_points = mean(NEXT_SCORE_EVENT_OFFENSE_DIFF, na.rm=T),
                  n = n(),
                  .groups = 'drop') %>%
        mutate(DOWN = factor(DOWN)) %>%
        ggplot(., aes(x=YARDS_TO_GOAL,
                      group = DOWN,
                      color = DOWN,
                      y=expected_points))+
        geom_point(aes(size=n))+
        geom_line(stat = 'smooth',
                  formula = 'y ~ x',
                  method = 'loess',
                  span = 0.25)+
        theme_phil()+
        geom_hline(yintercept = 0,
                   linetype = 'dotted')+
        scale_x_reverse()+
        scale_color_viridis_d()

```

We also have other features like distance.

```{r now look at by downs}

plays_data_score_events %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(YARD_LINE < 100 & YARD_LINE > 0) %>%
        filter(!(DISTANCE <0 | DISTANCE >=99)) %>%
        # group_by(DOWN, DISTANCE) %>%
        # count() %>%
        mutate(DOWN = factor(DOWN)) %>%
        ggplot(., aes(x=DISTANCE,
                      fill = DOWN))+
        geom_histogram(bins = 50)+
        facet_wrap(DOWN ~.,
                   ncol = 2,
                   scales = "free_y")+
        scale_fill_viridis_d()+
        theme_phil()
        

plays_data_score_events %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(YARD_LINE < 100 & YARD_LINE > 0) %>%
        filter(!(DISTANCE <0 | DISTANCE >=99)) %>%
        group_by(DISTANCE, DOWN) %>%
        summarize(expected_points = mean(NEXT_SCORE_EVENT_OFFENSE_DIFF, na.rm=T),
                  n = n(),
                  .groups = 'drop') %>%
        mutate(DOWN = factor(DOWN)) %>%
        ggplot(., aes(x=log1p(DISTANCE),
                      group = DOWN,
                      color = DOWN,
                      y=expected_points))+
        geom_point(aes(size=n))+
        geom_line(stat = 'smooth',
                  formula = 'y ~ x',
                  method = 'loess',
                  span = 0.25)+
        theme_phil()+
        geom_hline(yintercept = 0,
                   linetype = 'dotted')+
        scale_color_viridis_d()


```

As well as time remaining in the half.

```{r look at outcomes as a function of time remaining}

plays_data_score_events %>%
        filter(FLAG_SECONDS_IN_HALF != 1) %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        filter(DOWN %in% c(1,2,3,4)) %>%
        filter(YARD_LINE < 100 & YARD_LINE > 0) %>%
        mutate(SECONDS_IN_HALF = plyr::round_any(SECONDS_IN_HALF, 5, ceiling)) %>%
        group_by(SECONDS_IN_HALF, NEXT_SCORE_EVENT_OFFENSE) %>%
        count() %>%
        ggplot(., aes(x=SECONDS_IN_HALF,
                      fill = NEXT_SCORE_EVENT_OFFENSE,
                      y=n))+
        geom_bar(position = 'fill',
                 stat='identity',
                 color = NA)+
        scale_fill_viridis_d(option = 'B')+
        theme_phil()+
        scale_x_reverse()

```

# Modeling

We'll now proceed to modeling. I'll set up training, validation, and test sets based around the season.

```{r set up split sequence}

# full plays
plays_full = plays_data_score_events %>%
        filter(PLAY_TYPE != 'Kickoff') %>%
        select(GAME_ID,
               DRIVE_ID,
               PLAY_ID,
               SEASON,
               HOME,
               AWAY,
               OFFENSE,
               DEFENSE,
               OFFENSE_SCORE,
               DEFENSE_SCORE,
               SCORING,
               PLAY_TEXT,
               PLAY_TYPE,
               NEXT_SCORE_EVENT_HOME,
               NEXT_SCORE_EVENT_HOME_DIFF,
               NEXT_SCORE_EVENT_OFFENSE,
               NEXT_SCORE_EVENT_OFFENSE_DIFF,
               YARD_LINE,
               HALF,
               PERIOD,
               MINUTES_IN_HALF,
               SECONDS_IN_HALF,
               DOWN,
               DISTANCE,
               YARD_LINE,
               YARDS_TO_GOAL) %>%
        filter(DOWN %in% c(1, 2, 3, 4)) %>%
        filter(PERIOD %in% c(1,2,3,4)) %>%
        filter(!is.na(SECONDS_IN_HALF)) %>%
        filter(DISTANCE >=0 & DISTANCE <=100) %>%
        filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        mutate(NEXT_SCORE_EVENT_OFFENSE = factor(NEXT_SCORE_EVENT_OFFENSE,
                                                 levels = c("No_Score",
                                                            "TD",
                                                            "FG",
                                                            "Safety",
                                                            "Opp_Safety",
                                                            "Opp_FG",
                                                            "Opp_TD"))) %>%
        arrange(SEASON, GAME_ID, PLAY_ID)

# training set
plays_train = plays_full %>%
        filter(SEASON >= 2012 & SEASON <2019)

# validation set
plays_valid = plays_full %>%
        filter(SEASON >= 2019 & SEASON <= 2020)

# test
plays_test = plays_full %>%
        filter(SEASON > 2020)

# make an initial split based on previously defined splits
valid_split = make_splits(list(analysis = seq(nrow(plays_train)),
                                 assessment = nrow(plays_train) + seq(nrow(plays_valid))),
                               bind_rows(plays_train,
                                         plays_valid))

# test split
test_split = make_splits(
        list(analysis = seq(nrow(plays_train) + nrow(plays_valid)),
             assessment = nrow(plays_train) + nrow(plays_valid) + seq(nrow(plays_test))),
        bind_rows(plays_train,
                  plays_valid,
                  plays_test))

```

I plan to use the following as features in a baseline model.

I'll now set up a recipe for the baseline model.

```{r create recipes}

baseline_recipe = recipe(NEXT_SCORE_EVENT_OFFENSE ~.,
                         data = plays_train) %>%
        update_role(all_predictors(),
                    new_role = "ID") %>%
        update_role(
                c("GAME_ID",
                  "DRIVE_ID",
                  "PLAY_ID",
                  "SEASON",
                  "HOME",
                  "AWAY",
                  "OFFENSE",
                  "DEFENSE",
                  "SCORING",
                  "OFFENSE_SCORE",
                  "DEFENSE_SCORE",
                  "PLAY_TEXT",
                  "PLAY_TYPE",
                  "NEXT_SCORE_EVENT_HOME",
                  "NEXT_SCORE_EVENT_HOME_DIFF",
                  "NEXT_SCORE_EVENT_OFFENSE_DIFF",
                  "YARD_LINE",
                  "MINUTES_IN_HALF",
                  "HALF"),
                new_role = "ID") %>%
        step_mutate(PERIOD_ID = PERIOD,
                    role = "ID") %>%
        # features we're inheriting
        update_role(
                c("PERIOD", 
                "SECONDS_IN_HALF",
                "DOWN",
                "DISTANCE",
                "YARDS_TO_GOAL"),
                new_role = "predictor") %>%
        # filters for issues
        step_filter(!is.na(NEXT_SCORE_EVENT_OFFENSE)) %>%
        step_filter(YARD_LINE <= 100 & YARD_LINE >=0) %>%
        step_filter(YARDS_TO_GOAL <=100 & YARD_LINE >=0) %>%
        step_filter(DOWN %in% c(1, 2, 3, 4)) %>%
        step_filter(DISTANCE >=0 & DISTANCE <=100) %>%
        step_filter(SECONDS_IN_HALF <=1800) %>%
        step_filter(!is.na(SECONDS_IN_HALF)) %>%
        step_filter(PERIOD_ID == 1 | PERIOD_ID == 2 | PERIOD_ID == 3 | PERIOD_ID == 4) %>%
        # create features
        step_mutate(KICKOFF = case_when(grepl("kickoff", tolower(PLAY_TEXT)) | grepl("kickoff", tolower(PLAY_TYPE))==T ~ 1,
                                        TRUE ~ 0)) %>%
        step_mutate(TIMEOUT = case_when(grepl("timeout", tolower(PLAY_TEXT)) ~ 1,
                                        TRUE ~ 0)) %>%
        step_filter(TIMEOUT != 1) %>%
        step_filter(KICKOFF != 1) %>%
        step_mutate(DOWN_TO_GOAL = case_when(DISTANCE == YARDS_TO_GOAL ~ 1,
                                             TRUE ~ 0)) %>%
        # step_mutate(RED_ZONE = case_when(YARDS_TO_GOAL <= 20 ~ 1,
        #                                  TRUE ~ 0)) %>%
      #  step_mutate(OFFENSE_LEAD = OFFENSE_SCORE - DEFENSE_SCORE) %>%
        step_mutate(DOWN = factor(DOWN)) %>%
        step_mutate(PERIOD = factor(PERIOD)) %>%
        step_log(DISTANCE, offset =1) %>%
        step_dummy(all_nominal_predictors()) %>%
        step_novel(all_nominal_predictors(),
                   new_level = "new") %>%
        step_interact(terms = ~ DISTANCE:(starts_with("DOWN_"))) %>%
        step_interact(terms = ~ YARDS_TO_GOAL:(starts_with("DOWN_"))) %>%
        step_interact(terms = ~ YARDS_TO_GOAL*SECONDS_IN_HALF) %>%
        check_missing(all_predictors()) %>%
        step_normalize(all_numeric_predictors())

```

## Workflows

I'll define the model I'll be using here, which is a multinomial logistic regression.

```{r define model objs}

# from glmnet
multinom_mod = multinom_reg(
  mode = "classification",
  engine = "glmnet",
  penalty = 0,
  mixture = NULL
)

```

I'll then create a workflow.

```{r craete workflow}

# create multinomial workflow
multinom_wf = workflow() %>%
        add_recipe(baseline_recipe) %>%
        add_model(multinom_mod)

# workflow settings
# metrics
class_metrics<-metric_set(yardstick::roc_auc,
                          yardstick::mn_log_loss)

# control for resamples
keep_pred <- control_resamples(save_pred = TRUE, 
                               save_workflow = TRUE,
                               allow_par=T)

```

I'll manually define resamples based on the seasons - rather than doing k-fold cross validation, I'll assign each season to be a fold and train and assess the model leaving one season out at a time.

```{r set up manual resamples by season}

# get unique seasons
seasons = unique(plays_train$SEASON) %>%
        sort

# define indices by seasons
indices = foreach(i = 1:length(seasons)) %do% {
        list(analysis = which(plays_train$SEASON != seasons[i]),
             assessment = which(plays_train$SEASON == seasons[i]))
}

# get the splits
splits <- lapply(indices, make_splits, data = plays_train)

# define rset object
manual_resamples = manual_rset(splits, 
                               paste("holdout:", seasons))

```

```{r register parallel cores}

# register parallel
library(doParallel)
numcores = parallel::detectCores()
registerDoParallel(numcores -2)

```

## Training

Now I'll train and assess on these resamples.

```{r fit on set, eval=F}

# fit to resamples
resamples_multinom = multinom_wf %>%
        fit_resamples(data = plays_train,
                      metrics = class_metrics,
                      resamples = manual_resamples,
                      control = keep_pred,
                      verbose=T)

# # save locally so as to not need to retrain everytime
write_rds(resamples_multinom,
     file = here::here("models", "resamples_expected_points.Rds"),
     compress = "gz")

```

```{r load previously run resamples}

resamples_multinom = read_rds(here::here("models", 
                                         "resamples_expected_points.Rds"))

```


```{r fit to training set}

# fit the model to the whole training set
fit_multinom = multinom_wf %>%
        fit(data = plays_train)

```

## Resampling Performance

```{r get results}

# collect metrics
resamples_multinom %>%
        collect_metrics(summarize=F) %>%
        mutate_if(is.numeric, round, 3) %>%
        select(id, .metric, .estimator, .estimate) %>%
        arrange(.metric)

```
## Inference

```{r get coefs, fig.height=6, fig.width=8, warning=F, message=F}

tidy(fit_multinom) %>%
        mutate(term = factor(term)) %>%
        mutate(term = relevel(term, ref = "(Intercept)")) %>%
        ggplot(., aes(y=term,
                      x=estimate))+
        geom_point()+
        facet_wrap(class~.)+
        theme_bw()+
        ggtitle("Coefficients from Multinomial Logistic Regression")

```

Understanding partial effects from a multinomial logit is already difficult, and I've thrown a bunch of interactions in there to make this even more difficult. I'll look at predicted probabilities using an observed values approach for particular features (using a sample rather than the full dataset to save time). This means taking the model and then altering the feature of interest for every observation and taking the average predicted probability for each outcome across all observations.

```{r look at predicted probabilities}

# define min and max for feature
setting = seq(1, 100, 2)

# loop over
pred_settings = foreach(i = 1:length(setting),
        .combine = bind_rows) %do% {
                
                set.seed(1999)
                fit_multinom %>%
                        predict(new_data = plays_train %>% 
                                        sample_n(10000) %>%
                                        mutate(YARDS_TO_GOAL = setting[i]),
                                type = 'prob') %>%
                        apply(., 2, mean) %>%
                        as.data.frame() %>%
                        rownames_to_column("outcome") %>% set_names(., c("outcome", ".pred")) %>%
                        mutate(YARDS_TO_GOAL = setting[i])
}

```

How is the probability of the next scoring event influenced by where the offense has possession?

```{r show probabilities by yards to goal}

# make my own color ramp
my_col = colorRampPalette(c("blue", "white", "red"))
score_palette = c(my_col(6)[1:3], "grey80", my_col(6)[4:6])

# now plot this effect
pred_settings %>%
        mutate(outcome = paste(gsub(".pred_", "Pr(", outcome), ")", sep="")) %>%
             mutate(outcome = factor(outcome,
                                levels = paste("Pr(", c("TD",
                                      "FG",
                                      "Safety",
                                      "No_Score",
                                      "Opp_Safety",
                                      "Opp_FG",
                                      "Opp_TD"),
                                      ")",
                                      sep =""))) %>%
        ggplot(., 
               aes(x=YARDS_TO_GOAL,
               y = .pred,
               color = outcome,
               group = outcome))+
        facet_wrap(outcome ~.,
                   ncol = 4)+
        geom_line(lwd=1.1)+
        # scale_color_viridis_d(option = 'B',
        #                    end = 0.8,
        #                    begin = 0.2)+        
        scale_color_manual(values = score_palette)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(color = guide_legend(title = 'Next Scoring Event',
                                    title.position = 'top'))+
        xlab("Yards to Opponent End Zone")+
        ylab("Pr(Next Scoring Event)")+
        coord_cartesian(ylim= c(0, 1))+
        geom_vline(xintercept = 50,
                   linetype = 'dotted')+
        ggtitle("Probability of Next Scoring Event by Offensive Field Position",
                subtitle = str_wrap("Predicted probabilities from multinomial logistic regression. Displaying probabilities using observed values approach for a sample of training set. Model trained on regular season college football plays from 2012-2020. ",
                                    120))

# now plot this effect
pred_settings %>%
        mutate(outcome = paste(gsub(".pred_", "Pr(", outcome), ")", sep="")) %>%
             mutate(outcome = factor(outcome,
                                levels = paste("Pr(", c("TD",
                                      "FG",
                                      "Safety",
                                      "No_Score",
                                      "Opp_Safety",
                                      "Opp_FG",
                                      "Opp_TD"),
                                      ")",
                                      sep =""))) %>%
        ggplot(., 
               aes(x=YARDS_TO_GOAL,
               y = .pred,
               fill = outcome,
               group = outcome))+
        geom_col(position = 'fill',
                 lwd=1.1)+
        # scale_fill_viridis_d(option = 'B',
        #                    end = 0.8,
        #                    begin = 0.2)+        
        scale_fill_manual(values = score_palette)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(fill = guide_legend(title = 'Next Scoring Event',
                                    title.position = 'top'))+
        xlab("Yards to Opponent End Zone")+
        ylab("Pr(Next Scoring Event)")+
        coord_cartesian(ylim= c(0, 1))+
        geom_vline(xintercept = 50,
                   linetype = 'dotted')+
        ggtitle("Probability of Next Scoring Event by Offensive Field Position",
                subtitle = str_wrap("Predicted probabilities from multinomial logistic regression. Displaying probabilities using observed values approach for a sample of training set. Model trained on regular season college football plays from 2012-2020. ",
                                    120))


```

How is this affected by the down?

```{r loop over yards to goal and down}

# define min and max for feature
setting_1 = seq(1, 100, 5)
setting_2 = c(1, 2, 3, 4)

# loop over both
pred_settings_12 = foreach(i = 1:length(setting_1),
                        .combine = bind_rows) %:% 
        foreach(j = 1:length(setting_2)) %do% {
                
                set.seed(1999)
                 fit_multinom %>%
                        predict(new_data = plays_train %>% 
                                        sample_n(10000) %>%
                                        mutate(YARDS_TO_GOAL = setting_1[i],
                                               DOWN = setting_2[j]),
                                type = 'prob') %>%
                        apply(., 2, mean) %>%
                        as.data.frame() %>%
                        rownames_to_column("outcome") %>% 
                        set_names(., c("outcome", ".pred")) %>%
                        mutate(YARDS_TO_GOAL = setting_1[i],
                               DOWN = setting_2[j])
                
        }
                
```

```{r look at predicted probs by down and yards to goal}

# now plot this effect
pred_settings_12 %>%
        mutate(outcome = paste(gsub(".pred_", "Pr(", outcome), ")", sep="")) %>%
             mutate(outcome = factor(outcome,
                                levels = paste("Pr(", c("TD",
                                      "FG",
                                      "Safety",
                                      "No_Score",
                                      "Opp_Safety",
                                      "Opp_FG",
                                      "Opp_TD"),
                                      ")",
                                      sep =""))) %>%
        mutate(DOWN = factor(DOWN)) %>%
        ggplot(., 
               aes(x=YARDS_TO_GOAL,
               y = .pred,
               color = DOWN,
               group = DOWN))+
        facet_wrap(outcome ~.,
                   ncol = 4)+
        geom_line(lwd=1.1)+
        scale_color_viridis_d(option = 'D',
                           begin = 0.2)+        
        theme_phil()+
        theme(legend.title = element_text())+
        guides(color = guide_legend(title = 'Down',
                                    title.position = 'top'))+
        xlab("Yards to Opponent End Zone")+
        ylab("Pr(Next Scoring Event)")+
        ggtitle("Probability of Next Scoring Event by Offensive Field Position and Down",
                subtitle = str_wrap("Predicted probabilities from multinomial logistic regression. Displaying probabilities using observed values approach for a sample of training set. Model trained on regular season college football plays from 2012-2020. ",
                                    120))

```

How does this translate into expected points?

```{r make expected points function}

# define function here
expected_points_func = function(x) {

        x %>%
                mutate(EP = 0 * `.pred_No_Score` + 
                               7 * .pred_TD + 3 * .pred_FG + 
                               2 * .pred_Safety + 
                               -2*`.pred_Opp_Safety` + 
                               -3*`.pred_Opp_FG` + 
                               -7*`.pred_Opp_TD`)
        
}

```

```{r expected points by distance and down}

# loop over both
point_settings_12 = foreach(i = 1:length(setting_1),
                        .combine = bind_rows) %:% 
        foreach(j = 1:length(setting_2)) %do% {
                
                set.seed(1999)
                 fit_multinom %>%
                        predict(new_data = plays_train %>% 
                                        sample_n(10000) %>%
                                        mutate(YARDS_TO_GOAL = setting_1[i],
                                               DOWN = setting_2[j]),
                                type = 'prob') %>%
                         expected_points_func %>%
                         summarize(EP = mean(EP)) %>%
                        mutate(YARDS_TO_GOAL = setting_1[i],
                               DOWN = setting_2[j])
                
        }

```

```{r plot expected points by distance and down}

# now plot this effect
point_settings_12 %>%
        mutate(DOWN = factor(DOWN)) %>%
        ggplot(., 
               aes(x=YARDS_TO_GOAL,
               y = EP,
               color = DOWN,
               group = DOWN))+
        # facet_wrap(outcome ~.,
        #            ncol = 4)+
        geom_line(lwd=1.1)+
        scale_color_viridis_d(option = 'D',
                           begin = 0.2)+        
        theme_phil()+
        geom_hline(yintercept = 0,
                   linetype = 'dashed')+
        theme(legend.title = element_text())+
        guides(color = guide_legend(title = 'Down',
                                    title.position = 'top'))+
        xlab("Yards to Opponent End Zone")+
        ylab("Expected Points")+
        ggtitle("Expected Points by Offensive Field Position and Down",
                subtitle = str_wrap("Expected points using probabilities from multinomial logistic regression. Displaying expected points a portion of the training set using observed values approach, Model trained on regular season college football plays from 2012-2020. ",
                                    120))+
        geom_vline(xintercept = 50,
                   linetype = 'dotted')

```

## Validation Set

We can evaluate the model via our leave-one-out approach, but we'll also predict the validation set as an additional check. I'll compare performance relative to a null model that simply predicts the incidence rate of each outcome in the training set.

```{r predict validation set}

preds_multinom = fit_multinom %>%
        predict(new_data = plays_valid,
                type = 'prob') %>%
        bind_cols(., 
                  fit_multinom %>%
                          predict(new_data = plays_valid)) %>%
        bind_cols(plays_valid,
                  .)

```


```{r get null preds}

# baseline rates in training set
train_rates = plays_train %>%
        group_by(NEXT_SCORE_EVENT_OFFENSE) %>%
        count() %>%
        ungroup() %>%
        mutate(prop = n / sum(n))

# predict null for all valid
preds_null = train_rates %>% 
        select(-n) %>%
        spread(NEXT_SCORE_EVENT_OFFENSE, prop) %>% 
        set_names(., paste(".pred_", names(.), sep="")) %>%
        mutate(.pred_class = factor('TD',
                                    levels = c("TD",
                                      "FG",
                                      "Safety",
                                      "No_Score",
                                      "Opp_Safety",
                                      "Opp_FG",
                                      "Opp_TD"))) %>%
        bind_cols(plays_valid,
                  .)
```


```{r yardstick assessment on validation, warning=F, message=F}

# roc_auc
bind_rows(preds_null %>%
                  mutate(method = 'null'),
          preds_multinom %>%
                  mutate(method = 'multinom')) %>%
        group_by(method) %>%
        yardstick::roc_auc(
                   NEXT_SCORE_EVENT_OFFENSE,
                   `.pred_No_Score`:`.pred_Opp_TD`,
           #        estimator = 'macro_weighted'
                   ) %>%
        mutate_if(is.numeric, round, 3) %>%
        flextable() %>%
        autofit()

# logloss
bind_rows(preds_null %>%
                  mutate(method = 'null'),
          preds_multinom %>%
                  mutate(method = 'multinom')) %>%
        group_by(method) %>%
        yardstick::mn_log_loss(
                   NEXT_SCORE_EVENT_OFFENSE,
                   `.pred_No_Score`:`.pred_Opp_TD`,
           #        estimator = 'macro_weighted'
                   ) %>%
        mutate_if(is.numeric, round, 3) %>%
        flextable() %>%
        autofit()

```

What's the log loss for each outcome?

```{r subpopulation log loss}

# roc_auc
bind_rows(preds_null %>%
                  mutate(method = 'null'),
          preds_multinom %>%
                  mutate(method = 'multinom')) %>%
        group_by(method, NEXT_SCORE_EVENT_OFFENSE) %>%
        yardstick::mn_log_loss(
                   NEXT_SCORE_EVENT_OFFENSE,
                   `.pred_No_Score`:`.pred_Opp_TD`,
                   na_rm=T,
           #        estimator = 'macro_weighted'
                   ) %>%
        mutate_if(is.numeric, round, 3) %>%
        spread(method, .estimate) %>%
        flextable() %>%
        autofit()

```

```{r rm}

rm(splits,
   pred_settings,
   pred_settings_12,
   point_settings_12)

```

# Examining Results

I'll now start diving into the predictions for individual plays as a means to evaluate plays and teams.

It's worth noting that we might see some season-level differences that make comparison across seasons difficult, since the predictions are all coming from slightly different models due to resampling.

```{r combine resamples with validation predictions}

predicted_plays = 
        resamples_multinom %>%
        select(.predictions) %>% 
        unnest() %>%
        bind_cols(., plays_train %>%
                          select(-NEXT_SCORE_EVENT_OFFENSE)) %>%
        bind_rows(.,
                  preds_multinom) %>%
        expected_points_func() # convert to expected points

```

Get expected points added for all plays. This part is a little wobbly, due to data quality issues with defining sequences. The basic thought here is to say, at the start of a play, we know the expected points for a team in that situation, EP_Pre. We then look to the next play to see the expected points for the team after the result of the previous play, EP_Post. EP_Added is the difference between these two outcomes from the perspective of the offense. 

This means that if the ball is turned over, but not scored, the team on offense becomes the defense and the sign of the expected points on the next play flips for their calculation. For events that produce touchdowns, I set EP_Post to be equal to the points scored on the play, 7 for touchdowns, 3 for FGs, 2 for safeties.

```{r compute expected points for all plays}

scored_plays = predicted_plays %>%
        select(SEASON, GAME_ID, DRIVE_ID, PLAY_ID, HALF, PERIOD, OFFENSE, DEFENSE, HOME, AWAY, OFFENSE_SCORE, DEFENSE_SCORE,SECONDS_IN_HALF, DOWN, DISTANCE, YARDS_TO_GOAL, PLAY_TEXT, EP, PLAY_TYPE, NEXT_SCORE_EVENT_OFFENSE) %>%
        # compute home and away score
        mutate(HOME_SCORE = case_when(OFFENSE == HOME ~ OFFENSE_SCORE,
                                      DEFENSE == HOME ~ DEFENSE_SCORE),
               AWAY_SCORE = case_when(DEFENSE == HOME ~ OFFENSE_SCORE,
                                      OFFENSE == HOME ~ DEFENSE_SCORE)) %>%
        # make features to denote scoring plays
        mutate(TOUCHDOWN = case_when(
                (grepl("TOUCHDOWN", PLAY_TEXT) | PLAY_TYPE == 'TD' | grepl("td|touchdown", tolower(PLAY_TYPE))) ~ 1,
                                     TRUE ~ 0)) %>%
        mutate(FG = case_when(
                (grepl("Field Goal", PLAY_TEXT) | PLAY_TYPE == 'FG' | grepl("fg|field goal", tolower(PLAY_TYPE))) ~ 1,
                                     TRUE ~ 0)) %>%
        mutate(SAFETY = case_when(
                grepl("safety", tolower(PLAY_TEXT)) ~ 1,
                 TRUE ~ 0)) %>%
        # compute the actual points added in the event of scoring plays
        mutate(Points_Added = case_when(TOUCHDOWN==1 & NEXT_SCORE_EVENT_OFFENSE == 'TD' ~ 7,
                                        TOUCHDOWN==1 & NEXT_SCORE_EVENT_OFFENSE == 'Opp_TD' ~ -7,
                                        FG==1 & NEXT_SCORE_EVENT_OFFENSE == 'FG' ~ 3,
                                        FG==1 & NEXT_SCORE_EVENT_OFFENSE == 'Opp_FG' ~ -3,
                                        SAFETY==1 & NEXT_SCORE_EVENT_OFFENSE == 'Safety' ~ 2,
                                        SAFETY==1 & NEXT_SCORE_EVENT_OFFENSE == 'Opp Safety' ~ -2)) %>%
        # rename expected points for play as EPA_Pre
        rename(EP_Pre = EP)  %>%
        # now, compute EPA_Pre, EPA_Post, EPA_Added for individual drives
        # all of these calculations are keeping plays in the order in which they appear from the API
         group_by(GAME_ID, OFFENSE, HALF, DRIVE_ID) %>%
        # compute EP_Post, the result of the play. right now i'm combining points and expected points, potentially problematic but
        # to use my most scientific defense possible, eh
        mutate(EP_Post = case_when(
                TOUCHDOWN == 1 ~ Points_Added,
                FG == 1 ~ Points_Added,
                SAFETY == 1 ~ Points_Added,
                TOUCHDOWN == 0 & FG ==0 & SAFETY==0  ~ dplyr::lead(EP_Pre,1))
               ) %>%
        mutate(EP_Added = EP_Post-EP_Pre) %>%
        # unfortunately, this doesn't catch what happens if possession changes before a scoring event
        # define a sequence as plays within a half where the score remains the same
        # add a sequence id
        bind_cols(.,
                  group_indices(., GAME_ID, HALF, HOME_SCORE, AWAY_SCORE) %>% # this creates a group index
                          as_tibble() %>%
                          rename(SEQUENCE = value)) %>%
        group_by(GAME_ID, HALF, SEQUENCE) %>%
        # now, if EP_Post is NA, it is because a drive ended without a scoring event, so the other team gets the ball
        # this means, flip the sign of the expected points for the next play (ie, what is the other teams EP now that they have the ball)
        # the difference in this case will be the result of the turnover/change in possession
        mutate(EP_Post = case_when(
                is.na(EP_Post) ~ -1*(dplyr::lead(EP_Pre,1)),
                                   TRUE ~ EP_Post)) %>%
        mutate(EP_Added = case_when(
                is.na(EP_Added) ~ EP_Post-EP_Pre,
                                   TRUE ~ EP_Added)) %>%
        ungroup()

```

## Game Results

I'll look at a few games, play by play, to get a sense of how this is looking. I'll pick one game completely at random, in no way influenced by my fandom.

```{r look at a game from 2013}

scored_plays %>%
        filter(SEASON == 2012) %>%
        filter(HOME == 'Alabama' & AWAY == 'Texas A&M') %>%
        select(SEASON, GAME_ID, DRIVE_ID, PLAY_ID, PERIOD, OFFENSE, DEFENSE, SECONDS_IN_HALF, DOWN, DISTANCE, YARDS_TO_GOAL, PLAY_TEXT, EP_Pre, EP_Post, EP_Added) %>%
        mutate_at(c("SEASON",
                    "GAME_ID",
                    "DRIVE_ID",
                    "PLAY_ID"),
                  ~ as.character(.)) %>%
        select(-DRIVE_ID, -GAME_ID) %>%
        mutate_if(is.numeric, round, 2) %>%
      #  arrange(desc(EP_Added)) %>%
        flextable() %>%
        autofit()

```

From this game, we can look at the top ten positive points added plays and the top ten negative points added plays.

```{r look at a game from 2014}

scored_plays %>%
        filter(SEASON == 2012) %>%
        filter(HOME == 'Alabama' & AWAY == 'Texas A&M') %>%
        select(SEASON, GAME_ID, DRIVE_ID, PLAY_ID, PERIOD, OFFENSE, DEFENSE, DOWN, DISTANCE, YARDS_TO_GOAL, PLAY_TEXT, EP_Pre, EP_Post, EP_Added) %>%
        mutate_at(c("SEASON",
                    "GAME_ID",
                    "DRIVE_ID",
                    "PLAY_ID"),
                  ~ as.character(.)) %>%
        select(-DRIVE_ID, -GAME_ID) %>%
        mutate_if(is.numeric, round, 2) %>%
        arrange(desc(EP_Added)) %>%
        head(10) %>%
        bind_rows(.,
                  scored_plays %>%
        filter(SEASON == 2012) %>%
        filter(HOME == 'Alabama' & AWAY == 'Texas A&M') %>%
        select(SEASON, GAME_ID, DRIVE_ID, PLAY_ID, PERIOD, OFFENSE, DEFENSE, DOWN, DISTANCE, YARDS_TO_GOAL, PLAY_TEXT, EP_Pre, EP_Post, EP_Added) %>%
        mutate_at(c("SEASON",
                    "GAME_ID",
                    "DRIVE_ID",
                    "PLAY_ID"),
                  ~ as.character(.)) %>%
        select(-DRIVE_ID, -GAME_ID) %>%
        mutate_if(is.numeric, round, 2) %>%
        arrange(EP_Added) %>%
        head(10)) %>%
        arrange(desc(EP_Added)) %>%
        flextable() %>%
        autofit()

```


## Team Offenses and Defenses by Game

Having scored all individual plays, we can now roll this up to whatever level of analysis we're interested in. We can, for instance, look at a team's offense game by game over this time period. Continuing to select a team at random, we'll look at A&M's offense by game.

```{r look at tamu offense by season by game}

scored_plays %>%
        # exclude kickoffs from this
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        # also field goals, not that interested in kicking performance at the minute
        filter(FG == 0) %>% # remove FGs
        filter(OFFENSE == 'Texas A&M') %>%
        group_by(SEASON, OFFENSE, GAME_ID) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = OFFENSE) %>%
        mutate(TYPE = "OFFENSE") %>%
        left_join(., games_data_raw %>%
                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
        mutate_if(is.numeric, round, 2) %>%
        mutate(game = row_number()) %>%
        mutate(SEASON = factor(SEASON)) %>%
        ggplot(., aes(x=game,
                      color = SEASON,
                  #    size = plays,
                      label = paste(OPPONENT, SEASON),
                      y = EPA_per_Play))+
        geom_point()+
   geom_line(lwd = 0.8,
                  alpha = 0.8,
                  stat = 'smooth',
                  method = 'loess',
                  span = 0.25,
                  se = F,
                  formula = 'y ~ x')+
        geom_text_repel(check_overlap=T,
                 # vjust=-1,
                  size = 2.5)+
        theme_phil()+
        facet_wrap(TEAM~.)+
        scale_color_viridis_d(option = 'B',
                              begin = 0.8,
                              end = 0.2)+
        geom_hline(yintercept =0,
                   linetype = 'dashed')


scored_plays %>%
        # exclude kickoffs from this
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        # also field goals, not that interested in kicking performance at the minute
        filter(FG == 0) %>% # remove FGs
        filter(OFFENSE == 'Texas A&M') %>%
        group_by(SEASON, OFFENSE, GAME_ID) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = OFFENSE) %>%
        mutate(TYPE = "OFFENSE") %>%
        left_join(., games_data_raw %>%
                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
        mutate_if(is.numeric, round, 2) %>%
        group_by(SEASON) %>%
        mutate(game = row_number()) %>%
        ungroup() %>%
        mutate(SEASON = factor(SEASON)) %>%
        ggplot(., aes(x=game,
                      color = SEASON,
                  #    size = plays,
                      label = OPPONENT,
                      y = EPA_per_Play))+
        geom_point()+
        geom_line(lwd = 0.8,
                  alpha = 0.8,
                  stat = 'smooth',
                  method = 'loess',
                  span = 0.25,
                  se = F,
                  formula = 'y ~ x')+
        geom_text(check_overlap=T,
                  vjust=-1,
                  size = 2.5)+
        theme_phil()+
        facet_wrap(TEAM ~ SEASON,
                   ncol = 3)+
        scale_color_viridis_d(option = 'B',
                              begin = 0.8,
                              end = 0.2)+
        geom_hline(yintercept =0,
                   linetype = 'dashed')

```

We can do the same thing, but looking at a team's defense - what was the expected points added for the opposing team's offense? In this case, negative is good - it means the opposing team's offense didn't perform well.

```{r look at tamu defense}

scored_plays %>%
        # exclude kickoffs from this
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        # also field goals, not that interested in kicking performance at the minute
        filter(FG == 0) %>% # remove FGs
        filter(DEFENSE == 'Texas A&M') %>%
        group_by(SEASON, DEFENSE, GAME_ID) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = DEFENSE) %>%
        mutate(TYPE = "DEFENSE") %>%
        left_join(., games_data_raw %>%
                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
        mutate_if(is.numeric, round, 2) %>%
        mutate(game = row_number()) %>%
        mutate(SEASON = factor(SEASON)) %>%
        ggplot(., aes(x=game,
                      color = SEASON,
                  #    size = plays,
                      label = paste(OPPONENT, SEASON),
                      y = EPA_per_Play))+
        geom_point()+
   geom_line(lwd = 0.8,
                  alpha = 0.8,
                  stat = 'smooth',
                  method = 'loess',
                  span = 0.25,
                  se = F,
                  formula = 'y ~ x')+
        geom_text_repel(check_overlap=T,
                 # vjust=-1,
                  size = 2.5)+
        theme_phil()+
        facet_wrap(TEAM~.)+
        scale_color_viridis_d(option = 'B',
                              begin = 0.8,
                              end = 0.2)+
        geom_hline(yintercept =0,
                   linetype = 'dashed')


scored_plays %>%
        # exclude kickoffs from this
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        # also field goals, not that interested in kicking performance at the minute
        filter(FG == 0) %>% # remove FGs
        filter(DEFENSE == 'Texas A&M') %>%
        group_by(SEASON, DEFENSE, GAME_ID) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = DEFENSE) %>%
        mutate(TYPE = "DEFENSE") %>%
        left_join(., games_data_raw %>%
                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
        mutate_if(is.numeric, round, 2) %>%
        group_by(SEASON) %>%
        mutate(game = row_number()) %>%
        ungroup() %>%
        mutate(SEASON = factor(SEASON)) %>%
        ggplot(., aes(x=game,
                      color = SEASON,
                  #    size = plays,
                      label = OPPONENT,
                      y = EPA_per_Play))+
        geom_point()+
        geom_line(lwd = 0.8,
                  alpha = 0.8,
                  stat = 'smooth',
                  method = 'loess',
                  span = 0.25,
                  se = F,
                  formula = 'y ~ x')+
        geom_text(check_overlap=T,
                  vjust=-1,
                  size = 2.5)+
        theme_phil()+
        facet_wrap(TEAM ~ SEASON,
                   ncol = 3)+
        scale_color_viridis_d(option = 'B',
                              begin = 0.8,
                              end = 0.2)+
        geom_hline(yintercept =0,
                   linetype = 'dashed')

```

I'll put these side by side for a really good team, like Bama. A good performance is one where team's offense EPA is higher than the points yielded by the defense.

```{r game by game offense defense alabama}

scored_plays %>%
        # exclude kickoffs from this
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        # also field goals, not that interested in kicking performance at the minute
        filter(FG == 0) %>% # remove FGs
        filter(OFFENSE == 'Alabama') %>%
        group_by(SEASON, OFFENSE, GAME_ID) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = OFFENSE) %>%
        mutate(TYPE = "OFFENSE") %>%
        left_join(., games_data_raw %>%
                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
        mutate_if(is.numeric, round, 2) %>%
        group_by(SEASON) %>%
        mutate(game = row_number()) %>%
        ungroup() %>%
        mutate(SEASON = factor(SEASON)) %>%
        bind_rows(.,
                  scored_plays %>%
                        # exclude kickoffs from this
                        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
                        # also field goals, not that interested in kicking performance at the minute
                        filter(FG == 0) %>% # remove FGs
                        filter(DEFENSE == 'Alabama') %>%
                        group_by(SEASON, DEFENSE, GAME_ID) %>%
                        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                                  plays = n(),
                                  .groups = 'drop') %>%
                        mutate(TEAM = DEFENSE) %>%
                        mutate(TYPE = "DEFENSE") %>%
                        left_join(., games_data_raw %>%
                                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                                  by = c("GAME_ID")) %>%
                        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
                        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
                        mutate_if(is.numeric, round, 2) %>%
                        group_by(SEASON) %>%
                        mutate(game = row_number()) %>%
                        ungroup() %>%
                        mutate(SEASON = factor(SEASON))
                  ) %>%
        ggplot(., aes(x=game,
                      color = TYPE,
                  #    size = plays,
                      label = OPPONENT,
                      y = EPA_per_Play))+
        geom_point()+
        geom_line(lwd = 0.8,
                  alpha = 0.8,
                  stat = 'smooth',
                  method = 'loess',
                  span = 0.25,
                  se = F,
                  formula = 'y ~ x')+
        geom_text(check_overlap=T,
                  vjust=-1,
                  size = 2.5)+
        theme_phil()+
        facet_wrap(TEAM ~ SEASON,
                   ncol = 3)+
        geom_hline(yintercept =0,
                   linetype = 'dashed')+
        scale_color_manual(values = c("red", "deepskyblue1"))+
        coord_cartesian(ylim = c(-.75, .75))

```

Okay let's look at a mediocre team, like Kansas.

```{r look at a mediocre team}

scored_plays %>%
        # exclude kickoffs from this
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        # also field goals, not that interested in kicking performance at the minute
        filter(FG == 0) %>% # remove FGs
        filter(OFFENSE == 'Kansas') %>%
        group_by(SEASON, OFFENSE, GAME_ID) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = OFFENSE) %>%
        mutate(TYPE = "OFFENSE") %>%
        left_join(., games_data_raw %>%
                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                  by = c("GAME_ID")) %>%
        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
        mutate_if(is.numeric, round, 2) %>%
        group_by(SEASON) %>%
        mutate(game = row_number()) %>%
        ungroup() %>%
        mutate(SEASON = factor(SEASON)) %>%
        bind_rows(.,
                  scored_plays %>%
                        # exclude kickoffs from this
                        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
                        # also field goals, not that interested in kicking performance at the minute
                        filter(FG == 0) %>% # remove FGs
                        filter(DEFENSE == 'Kansas') %>%
                        group_by(SEASON, DEFENSE, GAME_ID) %>%
                        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                                  plays = n(),
                                  .groups = 'drop') %>%
                        mutate(TEAM = DEFENSE) %>%
                        mutate(TYPE = "DEFENSE") %>%
                        left_join(., games_data_raw %>%
                                          select(GAME_ID, HOME_TEAM, AWAY_TEAM),
                                  by = c("GAME_ID")) %>%
                        mutate(OPPONENT = case_when(HOME_TEAM == TEAM ~ AWAY_TEAM,
                                                    AWAY_TEAM == TEAM ~ HOME_TEAM)) %>%
                        select(SEASON, GAME_ID, TEAM, OPPONENT, TYPE, EPA_per_Play, plays) %>%
                        mutate_if(is.numeric, round, 2) %>%
                        group_by(SEASON) %>%
                        mutate(game = row_number()) %>%
                        ungroup() %>%
                        mutate(SEASON = factor(SEASON))
                  ) %>%
        ggplot(., aes(x=game,
                      color = TYPE,
                  #    size = plays,
                      label = OPPONENT,
                      y = EPA_per_Play))+
        geom_point()+
        geom_line(lwd = 0.8,
                  alpha = 0.8,
                  stat = 'smooth',
                  method = 'loess',
                  span = 0.25,
                  se = F,
                  formula = 'y ~ x')+
        geom_text(check_overlap=T,
                  vjust=-1,
                  size = 2.5)+
        theme_phil()+
        facet_wrap(TEAM ~ SEASON,
                   ncol = 3)+
        geom_hline(yintercept =0,
                   linetype = 'dashed')+
        scale_color_manual(values = c("red", "deepskyblue1"))+
        coord_cartesian(ylim = c(-.75, .75))

```

## Team Offenses and Defenses by Year

We can then aggregate this to a team's offensive performance within a full year to rate their overall offensive/defensive efficiency. We can also break this down by passing vs rushing plays on both sides of the ball.

For the purpose of evaluating a team's defense, I'll flip the sign of the points, which are currently scored from the perspective of the offense, so that positive is always good for a team.

```{r look at expected points at the season level}

# offense
yearly_offense_epa = scored_plays %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        filter(FG == 0) %>% # remove FGs
        group_by(SEASON, OFFENSE) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = OFFENSE) %>%
        mutate(TYPE = "OFFENSE") %>%
        select(SEASON, TEAM, TYPE, EPA_per_Play, plays)

# offense by play type
yearly_offense_epa_by_play = scored_plays %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        mutate(PLAY = case_when(
                grepl("pass|completion|sack|intercept", tolower(PLAY_TYPE)) ~ 'Pass',
                grepl("run|rush", tolower(PLAY_TYPE)) ~ 'Run',
                TRUE ~ 'Special')) %>%
        filter(FG == 0) %>% # remove FGs
        group_by(SEASON, OFFENSE, PLAY) %>%
        summarize(EPA_per_Play = mean(EP_Added, na.rm=T),
                  Plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = OFFENSE) %>%
        mutate(TYPE = "OFFENSE") %>%
        select(SEASON, TEAM, TYPE, PLAY, EPA_per_Play, Plays)

# defense
yearly_defense_epa = scored_plays %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        filter(FG == 0) %>% # remove FGs
        group_by(SEASON, DEFENSE) %>%
        summarize(EPA_per_Play = -1*mean(EP_Added, na.rm=T),
                  plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = DEFENSE) %>%
        mutate(TYPE = "DEFENSE") %>%
        select(SEASON, TEAM, TYPE, EPA_per_Play, plays)

# defense by play type
yearly_defense_epa_by_play = scored_plays %>%
        filter(!grepl("kickoff", tolower(PLAY_TYPE))) %>%
        mutate(PLAY = case_when(
                grepl("pass|completion|sack|intercept", tolower(PLAY_TYPE)) ~ 'Pass',
                grepl("run|rush", tolower(PLAY_TYPE)) ~ 'Run',
                TRUE ~ 'Special')) %>%
        filter(FG == 0) %>% # remove FGs
        group_by(SEASON, DEFENSE, PLAY) %>%
        summarize(EPA_per_Play = -1*mean(EP_Added, na.rm=T),
                  Plays = n(),
                  .groups = 'drop') %>%
        mutate(TEAM = DEFENSE) %>%
        mutate(TYPE = "DEFENSE") %>%
        select(SEASON, TEAM, TYPE, PLAY, EPA_per_Play, Plays)
        
```

Putting this all together, I can rank a teams offense/defense by year and then sort to see where the top teams of all time tend to rank. Here are the top 50 teams using a composite score of both, including only offenses and defenses with at least 400 plays in a season.

```{r look at overall offense defense per team season}

yearly_teams = bind_rows(yearly_offense_epa,
          yearly_defense_epa) %>%
        pivot_wider(id_cols = c("SEASON", 
                                "TEAM"),
                    values_from = c("EPA_per_Play", "plays"),
                    names_from = c("TYPE")) %>%
        filter(plays_OFFENSE & plays_DEFENSE > 400) %>%
        rename(OFFENSE_EPA = EPA_per_Play_OFFENSE,
               DEFENSE_EPA = EPA_per_Play_DEFENSE) %>%
        select(SEASON, TEAM, OFFENSE_EPA, DEFENSE_EPA) %>%
        mutate(OVERALL = OFFENSE_EPA + DEFENSE_EPA)

yearly_teams %>%
        mutate(SEASON = as.character(SEASON)) %>%
        mutate_if(is.numeric, round, 2) %>%
        arrange(desc(OVERALL)) %>%
        mutate(Rank = row_number()) %>%
        select(Rank, everything()) %>%
        head(50) %>%
        flextable() %>%
        autofit()

```

And here are the 25 worst teams using the same criterion.

```{r bottom overall by season}

yearly_teams %>%
        mutate(SEASON = as.character(SEASON)) %>%
        mutate_if(is.numeric, round, 2) %>%
        arrange(desc(OVERALL)) %>%
        mutate(Rank = row_number()) %>%
        select(Rank, everything()) %>%
        arrange(OVERALL) %>%
        head(25) %>%
        flextable() %>%
        autofit()

```

We can visualize all of this by placing every team based on its overall offensive/defensive efficiency.

```{r make plot for overall}

yearly_teams %>%
        mutate(SEASON = as.character(SEASON)) %>%
        ggplot(., aes(x=OFFENSE_EPA,
                      color = OVERALL,
                      label = paste(TEAM, SEASON, sep=" "),
                      y=DEFENSE_EPA))+
        geom_vline(xintercept = 0,
                   linetype = 'dashed',
                   color = 'black')+
        geom_hline(yintercept = 0,
                   linetype = 'dashed',
                   color = 'black')+
        geom_point(alpha = 0.5)+
                   #color = 'grey60')+
        geom_text(check_overlap = T,
                  size = 2.5,
                  hjust=0.5,
                  vjust = -1)+
        theme_phil()+
        coord_cartesian(xlim= c(-0.4, 0.4),
                        ylim = c(-0.4, 0.4))+
        annotate("label",
                 x=-0.25,
                 y=0.3,
                 label = "Bad Offense \n Good Defense")+
        annotate("label",
                 x=0.3,
                 y=-0.3,
                 label = "Good Offense \n Bad Defense")+
        annotate("label",
                 x=0.3,
                 y=0.3,
                 label = "Good Offense \n Good Defense")+
        annotate("label",
                 x=-0.25,
                 y=-0.3,
                 label = "Bad Offense \n Bad Defense")+
        ggtitle("College Football Teams, 2012-2020",
                subtitle = "Teams placed based on regular season offense and defense efficiency")+
        scale_color_gradient(low = "red", high = "deepskyblue1",
                             limits = c(-0.25, 0.25),
                             oob = scales::squish)+
        theme(legend.title = element_text())+
        guides(color = guide_colorbar(barheight = 0.5,
                                      title = 'Team EPA Overall',
                                      title.position = 'top',
                                     barwidth = 10))

```

Stop here for now.

# Backtesting

I'll next use the model we trained on 2012-2020 to evaluate prior seasons.