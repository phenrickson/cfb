---
title: "Building a CFB In Game Win Probability Model"
author: "Phil Henrickson"
date: "6/7/2022"
output: 
  html_document:
    toc: TRUE #adds a Table of Contents
    theme: cerulean
    number_sections: TRUE #number your headings/sections
    toc_float: TRUE #let your ToC follow you as you scroll
    keep_md: no
    fig.caption: yes
    css: "styles.css"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = F,
                      error = F,
                      warning=F,
                      dev="png",
                      fig.width = 10,
                      fig.height = 6)

options(knitr.duplicate.label = "allow")

options(scipen=999)

```


```{r connect to snowflake}

library(DBI)
library(odbc)
library(RODBC)
library(keyring)


# connect to snowflake
myconn <- DBI::dbConnect(odbc::odbc(),
                         "SnowflakeDSII",
                         Database = "CFB_DEMO",
                         warehouse = "DEMO_WH",
                         uid="phil.henrickson",
                         pwd=keyring::key_get("AE_Snowflake"))

```

```{r packages, include=F} 

source(here::here("scripts/load_packages.R"))
library(jsonlite)
library(forcats)
library(rstan)
library(rstanarm)
library(rstantools)
library(broom)
library(broom.mixed)
library(tidybayes)

conflict_prefer("lag", "dplyr")

library(flextable)
set_flextable_defaults(theme_fun = theme_alafoli,
                       font.color = "grey10",
                       font.size=8,
                       padding.bottom = 6, 
                       padding.top = 6,
                       padding.left = 6,
                       padding.right = 6,
                       background.color = "white")


```

```{r load functions}

source(here::here("functions/theme_phil.R"))
source(here::here("functions/clean_plays_func.R"))
rm(a)
```

```{r get games and croots data, include=F}

# get games
games_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.GAMES')) %>%
        as_tibble() %>%
        mutate(ID = as.numeric(ID)) %>%
        rename(GAME_ID = ID)

# get lines
games_lines_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.LINES')) %>%
        as_tibble() %>%
        mutate(ID = as.numeric(ID)) %>%
        rename(GAME_ID = ID)

# now get the lines out of json
games_lines = games_lines_raw %>%
        nest(-GAME_ID) %>%
        mutate(PRE_GAME_LINES = map(data, ~ fromJSON(.x$LINES) %>%
                                            as_tibble())) %>%
        select(GAME_ID, PRE_GAME_LINES) %>%
        unnest(PRE_GAME_LINES)

# get recruiting teams
recruiting_teams_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.RECRUITING_TEAMS')) %>%
        as_tibble() %>%
        mutate(POINTS = as.numeric(POINTS))

# get individual plays
plays_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.PLAY_BY_PLAY')) %>%
        as_tibble() %>%
        mutate(TIME = gsub('\\{|}|"', '', CLOCK)) %>%
        separate(TIME, into=c("MINUTES", "SECONDS"), sep=",") %>%
        mutate(MINUTES = as.numeric(gsub("minutes:", "", MINUTES))) %>% 
        mutate(SECONDS = as.numeric(gsub("seconds:", "", SECONDS))) %>%
        mutate(MINUTES_IN_HALF = case_when(PERIOD == 1 ~ MINUTES+ 15,
                                           PERIOD == 2 ~ MINUTES,
                                           PERIOD == 3 ~ MINUTES + 15,
                                           PERIOD == 4 ~ MINUTES)) %>%
        mutate(SECONDS_IN_HALF = MINUTES_IN_HALF*60 + SECONDS) %>%
        # flag if seconds in half is invalid
        mutate(FLAG_SECONDS_IN_HALF = case_when(SECONDS_IN_HALF > 1800 ~ 1,
                                                TRUE ~ 0)) %>%
        # convert IDs to numeric
        mutate(ID = as.numeric(ID),
               DRIVE_ID = as.numeric(DRIVE_ID)) %>%
        rename(PLAY_ID = ID) %>%
        group_by(GAME_ID) %>%
        # sort each game by drive
        arrange(PLAY_ID) %>% 
        ungroup() %>%
        # clean up PERIOD by game
        mutate(STATUS_PERIOD = case_when(PERIOD == 0 & nchar(PLAY_TEXT) <=1 ~ 'Drop',
                                        PERIOD == 0 ~ 'Take Previous Value',
                                        TRUE ~ 'Valid')) %>%
        filter(STATUS_PERIOD != 'Drop') %>%
        mutate(PERIOD = case_when(STATUS_PERIOD == 'Take Previous Value' ~ lag(PERIOD, 1),
                                  TRUE ~ PERIOD)) %>%
        ungroup() %>% 
        mutate(HALF = case_when(PERIOD == 1 ~ 'First Half',
                                PERIOD == 2 ~ 'First Half',
                                PERIOD == 3 ~ 'Second Half',
                                PERIOD == 4 ~ 'Second Half',
                                TRUE ~ 'OT')) %>%
        # then clean up the down
        mutate(FLAG_DOWN = case_when(DOWN %in% c(1, 2, 3, 4) ~ 0,
                                       TRUE ~ 1)) %>%
        mutate(DOWN = case_when(DOWN %in% c(1, 2, 3, 4) ~ DOWN,
                                TRUE ~ -1)) %>%
        # then flag the distance
        mutate(FLAG_DISTANCE = case_when((DISTANCE < 0 | DISTANCE >=99) ~ 1,
                                         TRUE ~ 0)) %>%
        # flag yard lines that are outside correct
        mutate(FLAG_YARD_LINE = case_when(YARD_LINE < 0 | YARD_LINE > 100 ~ 1,
                                          TRUE ~ 0))

```

```{r flag games with too few plays}

# check for games that are incomplete
# games missing plays in a quarter
problem_games = c(plays_data_raw %>%
        left_join(., games_data_raw,
                  by = c("GAME_ID")) %>%
        group_by(SEASON, PERIOD, GAME_ID) %>%
        count() %>%
        filter(PERIOD %in% c(1, 2, 3, 4)) %>%
        mutate(PERIOD = paste("PERIOD", PERIOD, sep="_")) %>%
        spread(PERIOD, n) %>%
        ungroup() %>%
        mutate_if(is.numeric, replace_na, 0) %>%
        mutate(MISSING_PERIOD = case_when(PERIOD_1 <10 | 
                                                  PERIOD_2 <10 | 
                                                  PERIOD_3 <10 | 
                                                  PERIOD_4 <10 ~ TRUE)) %>%
        filter(MISSING_PERIOD == T) %>%
        pull(GAME_ID),
        # games where the scoreline is just wrong at the start of the game
        plays_data_raw %>%
                left_join(., games_data_raw,
                          by = c("GAME_ID")) %>%
                filter(HALF == 'First Half' & SECONDS_IN_HALF == 1800) %>%
                mutate(SCORE_DIFF = abs(OFFENSE_SCORE - DEFENSE_SCORE)) %>%
                filter(SCORE_DIFF > 7) %>% 
                select(GAME_ID, PLAY_ID, everything()) %>%
                pull(GAME_ID))

```



```{r plays with games data}

# combine 
plays_outcomes = plays_data_raw %>%
        select(GAME_ID,
               DRIVE_ID,
               PLAY_ID,
               HALF,
               PERIOD,
               HOME,
               AWAY,
               OFFENSE,
               OFFENSE_SCORE,
               OFFENSE_TIMEOUTS,
               DEFENSE,
               DEFENSE_SCORE,
               DEFENSE_TIMEOUTS,
               DOWN,
               DISTANCE,
               SECONDS_IN_HALF,
               YARDS_TO_GOAL,
               PLAY_TYPE,
               PLAY_TEXT,
               SCORING,
               YARD_LINE) %>%
        left_join(., games_data_raw %>%
                          filter(!(GAME_ID %in% problem_games)) %>%
                          select(GAME_ID,
                                 SEASON,
                                 WEEK,
                                 SEASON_TYPE,
                                 START_DATE,
                                 NEUTRAL_SITE,
                                 CONFERENCE_GAME,
                                 ATTENDANCE,
                                 VENUE_ID,
                                 VENUE,
                                 HOME_ID,
                                 HOME_POINTS,
                                 HOME_CONFERENCE,
                                 HOME_PREGAME_ELO,
                                 AWAY_ID,
                                 AWAY_POINTS,
                                 AWAY_CONFERENCE,
                                 AWAY_PREGAME_ELO),
                  by = c("GAME_ID")) %>%
        # make outcome
        mutate(HOME_WIN = case_when(HOME_POINTS > AWAY_POINTS ~ 'yes',
                                    HOME_POINTS < AWAY_POINTS ~ 'no')) %>%
        mutate(OFFENSE_HOME= case_when(OFFENSE == HOME ~ 'yes',
                                    TRUE ~ 'no')) %>%
        mutate(HOME_SCORE = case_when(OFFENSE == HOME ~ OFFENSE_SCORE,
                                      OFFENSE == AWAY ~ DEFENSE_SCORE),
               AWAY_SCORE = case_when(OFFENSE == HOME ~ DEFENSE_SCORE,
                                      OFFENSE == AWAY ~ OFFENSE_SCORE)) %>%
        # remove overtime 
        filter(PERIOD %in% c(1, 2, 3, 4)) %>%
        # create indicator for home team on offense
        mutate(IS_HOME_OFFENSE = case_when(HOME == OFFENSE ~ "yes",
                                           TRUE ~ "no")) %>%
        # create indicator for neutral site
        mutate(NEUTRAL_SITE = case_when(NEUTRAL_SITE == T ~ 'yes',
                                        TRUE ~ 'no'))
        
        
```

# Learning In Game Win Probabilities

In this notebook I develop and explore a win classification model built at the play level in order to determine in game win probabilities. The goal of this analysis is to determine how the circumstances within a game (down, distance, score differential) affect the probability of each team winning the game. Once we've learned these probabilities, we can find how individual plays changed each team's expected outcome, as welll as which games had the most changes in who was likely to win.

The data used is from college football games from 2003 to present. Each observation represents one play in a game, in which we know the team, the situation (down, time remaining), and the location on the field (yards to go, yards to reach end zone). We have information about the types of plays called as well in a text field.

## Outcome and Predictors

The outcome for this analysis is a binary outcome indicating whether the home team won or lost the game, **HOME WIN**. For each game, this outcome will be static. The predictors in the model are at the individual play level and will be evaluated from the perspective of the team in possession of the ball. I will be using the following features to start:

* Score Differential
* Down
* Yards to First Down (Distance)
* Yards to Opponent Goal Line
* Half Seconds Remaining
* Game Seconds Remaining
* Is Home Team on Offense - dummy to indicate that the team with the ball is the home team
* Offense Time Outs Remaining
* Defense Time Outs Remaining
* Neutral Site - dummy to indicate that 

For an example of what the play by play data looks like, here are the first few plays of Auburn vs Georgia in 2013.

<!-- * Possession Team 2nd Half Kickoff - dummy to indicate that the team in possession will receive the ball in the second half -->

```{r examine games}

plays_outcomes %>%
        filter(SEASON == 2013 & HOME == 'Auburn' & AWAY == 'Georgia') %>%
        mutate(OFF_HOME= case_when(OFFENSE == HOME ~ 'yes',
                                    TRUE ~ 'no')) %>%
        mutate(OFF_TO = OFFENSE_TIMEOUTS,
               DEF_TO = DEFENSE_TIMEOUTS) %>%
        rename(YTG = YARDS_TO_GOAL) %>%
        mutate(SEASON = factor(SEASON)) %>%
        select(SEASON, OFFENSE, DEFENSE, OFF_HOME, SECONDS_IN_HALF, DOWN, DISTANCE, YTG, PLAY_TEXT, OFF_TO, DEF_TO) %>%
        head() %>%
        flextable() %>%
        autofit()

```

Every one of these features of plays shifts the probability that the home or away team will win. The model learns this probability by learning the relationship between the features of each play and the outcome of the game.

## Team Effects

If we include no features to account for the teams playing, the probability of every game will start at around 50% (a little bit more, as the home team is generally favored) and will move in response to events of the game. This means that if Kansas is playing at Alabama and Kansas manages to score an early field goal, the model will have Kansas favored to win at that point. That doesn't feel right, as we would expect Bama to be able to comfortably whether a 3 point deficit against a weaker opponent. We would expect their win probability going into the game to already be high and only be marginally effected by the events early on in the game. 

* Home Elo Diff = Home Pregame Elo - Away Pregame Elo

We can add this component into the model by incorporating information about the relative strength of the two teams going into the game. We could also use the pregame spread to proxy for this, but I'm going to use the difference in the two teams pre game Elo ratings. 
In the case of the game between Auburn and Georgia, Georgia had a higher Elo rating going into this game and would have been a slight favorite coming into the game even as the away team.

```{r look at the same game as before nut now look at ELO}

plays_outcomes %>%
        filter(SEASON == 2013 & HOME== 'Auburn' & AWAY == 'Georgia') %>%
        mutate(HOME_ELO_DIFF = HOME_PREGAME_ELO - AWAY_PREGAME_ELO) %>%
        select(SEASON, HOME, AWAY, HOME_PREGAME_ELO, AWAY_PREGAME_ELO, HOME_ELO_DIFF) %>%
        head(1) %>%
        flextable() %>%
        autofit()

```

# Modeling In Game Probabilities

I'll now get right to it and start getting to know the data for the purpose of training the model. I'll use the seasons from 2012 onwards, as I've found these to have fewer data quality issues than the years before. I can backtest the model on games before this, which will help highlight some of the data quality issues I've noticed in exploring the data.

## Design

I'll split the data into training, validation, and test sets based on the seasons. I'll use the seasons from 2013-2017 as my main training set (currently don't have data on timeouts before 2013), holding back 2018-2020 as my validation set and leaving 2021 as the final season that I won't look at until all modeling decisions have been made. 

```{r set up training and test splits, eval=T}

plays_train = plays_outcomes %>%
        filter(SEASON >= 2013 & SEASON <=2017)

plays_valid = plays_outcomes %>%
        filter(SEASON > 2017 & SEASON <=2020)

plays_test = plays_outcomes %>%
        filter(SEASON > 2020)
        
```

I'll assess the model in two different ways: I'll adopt a leave-one-season-out approach on the training set, repeatedly training the model on all seasons but one and then predicting that season. I'll look at the performance in resampling to get a sense of how well the model is performing, where I'm mostly interested in evaluating the calibration of the model. 

```{r set up leave one season out, eval=T}

# get unique seasons
seasons = unique(plays_train$SEASON) %>%
        sort

# define indices by seasons
season_indices = foreach(i = 1:length(seasons)) %do% {
        list(analysis = which(plays_train$SEASON != seasons[i]),
             assessment = which(plays_train$SEASON == seasons[i]))
}

# get the splits
splits <- lapply(season_indices, make_splits, data = plays_train)

# define rset object
manual_resamples = manual_rset(splits, 
                               paste(seasons))
```

I'll then retrain the model on the entirety of the training set and predict the validation set to see how well the model does on new seasons. 

```{r validation and test split}

# make an initial split based on previously defined splits
valid_split = make_splits(list(analysis = seq(nrow(plays_train)),
                                 assessment = nrow(plays_train) + seq(nrow(plays_valid))),
                               bind_rows(plays_train,
                                         plays_valid))

# test split
test_split = make_splits(
        list(analysis = seq(nrow(plays_train) + nrow(plays_valid)),
             assessment = nrow(plays_train) + nrow(plays_valid) + seq(nrow(plays_test))),
        bind_rows(plays_train,
                  plays_valid,
                  plays_test))

```

## Examining the Data

Now that I've split up the data, I want to look at the training set to get to know the data a bit. In the training set, the home team won about 62% of the time (not including neutral site games).

```{r look at outcomes}

plays_train %>%
        filter(NEUTRAL_SITE =='no') %>%
        select(GAME_ID, HOME_WIN) %>%
        distinct() %>%
        group_by(HOME_WIN) %>%
        count() %>%
        ungroup() %>%
        mutate(prop = n / sum(n)) %>%
        mutate_if(is.numeric, round, 2) %>%
        flextable() %>%
        autofit()

```

This has been a pretty consistent result across all seasons and all conferences with a few exceptions (the Sun Belt and MAC buck the trend a bit).

```{r look at home win rate by season and conference}

library(forcats)

plays_train %>%
        filter(!is.na(HOME_CONFERENCE)) %>%
        filter(NEUTRAL_SITE == 'no') %>%
        select(SEASON, GAME_ID, HOME_WIN, HOME_CONFERENCE) %>%
        distinct() %>%
        group_by(SEASON, HOME_CONFERENCE, HOME_WIN) %>%
        count() %>%
        group_by(SEASON, HOME_CONFERENCE) %>%
        mutate(prop = n / sum(n)) %>%
        filter(HOME_WIN == 'yes') %>%
        mutate(SEASON = factor(SEASON)) %>%
        mutate(HOME_CONFERENCE = fct_rev(HOME_CONFERENCE)) %>%
        ggplot(., aes(x=SEASON,
                      fill = prop,
                      y=HOME_CONFERENCE)) +
        geom_text(aes(label = paste(round(prop, 2))))+
        geom_tile(color = 'white',
                  width=0.9, height=0.8)+
        scale_fill_gradient2(low = "red",
                             mid = 'grey90',
                            high = 'deepskyblue1',
                            midpoint =0.5,
                            limits = c(0.25, 0.75),
                            oob = scales::squish)+
        theme_phil()+
        theme(panel.grid.major = element_blank(),
              legend.title = element_text())+
        guides(fill = guide_colorbar(barwidth = 10,
                                    barheight = 0.5,
                                    title = 'Home Team Win Probability',
                                    title.position = 'top'))+
        ggtitle("When Does the Home Team Win i?",
                str_wrap("Home team win percentage for college football games by conference and season", 90))


```

The bulk of our analysis is going to be on the features of the game situation. I'll plot these mainly to get a sense of whether anything funky is going on with their distributions.

```{r plot features of games}

set.seed(19)
plays_train %>%
        mutate(HOME_SCORE_DIFF = HOME_SCORE - AWAY_SCORE) %>%
        mutate(HOME_ELO_DIFF = HOME_PREGAME_ELO - AWAY_PREGAME_ELO) %>%
        select(HOME_SCORE_DIFF, HOME_ELO_DIFF, OFFENSE_TIMEOUTS, DEFENSE_TIMEOUTS, SECONDS_IN_HALF, YARDS_TO_GOAL, DOWN, DISTANCE) %>%
        gather("variable", "value") %>%
        ggplot(., aes(x=value))+
        geom_histogram(bins = 80)+
        facet_wrap(variable ~.,
                   ncol = 3,
                   scales = "free")+
        theme_phil()

```

Couple of things jump out here. It looks like we'll need to clean up the time outs features (how can you have -2 timeouts?) and also indicate that when the down is -1 it's a special teams play. Similarly, we've got a couple of plays in here which seem to be over 100 yards to go, which is, uh, impossible on a football field. That'll need to be cleaned up.

What's going on with those big spikes in the seconds in the half variable? The biggest spike is 1800, and the fact that we have so many plays at the 1800 second mark is probably due to kickoffs that don't take any time off the clock. The second spike is at the 900 second mark, which means we have plays occuring at the first minute of the second quarter. 

In terms of how these features relate to the outcome, we are probably going to be most interested in the score differential + time remaining. At any given point in the game, we would expect the probability that the home team wins is going to be some nonlinear function of how much they're losing/winning by and the amount of time left in the game.

### How Often Does the Home Team Win?

I'll plot the proportion of times the home team won at every ten second interval of time remaining. By itself, we don't see muc of an effect on time remaining, as it depends on the score. 

```{r home team time remaining}

plays_train %>%
        mutate(SECONDS_IN_GAME = case_when(HALF == 'First Half' ~ SECONDS_IN_HALF + 1800,
                                           HALF == 'Second Half' ~ SECONDS_IN_HALF)) %>%
        mutate(SECONDS_IN_GAME = plyr::round_any(SECONDS_IN_GAME, 5, floor)) %>%
        group_by(HOME_WIN, SECONDS_IN_GAME) %>%
        count() %>%
        group_by(SECONDS_IN_GAME) %>%
        mutate(prop = n / sum(n)) %>%
        filter(HOME_WIN == 'yes') %>%
        ggplot(., aes(x=SECONDS_IN_GAME,
                      y = prop))+
        geom_point()+
        coord_cartesian(ylim = c(0,1))+
        geom_smooth(formula = 'y ~ x',
                    method = 'loess')+
        theme_phil()

```

I'll now make the same plot, but facet by whether the home team is leading or trailing.

```{r look at home team winner as a function of time and score}

my_col = colorRampPalette(c("blue", "white", "red"))
score_palette = c(my_col(9)[1:4], "grey80", my_col(9)[6:9])

plays_train %>%
        mutate(HOME_SCORE_DIFF = HOME_SCORE - AWAY_SCORE) %>%
        mutate(SECONDS_IN_GAME = case_when(HALF == 'First Half' ~ SECONDS_IN_HALF + 1800,
                                           HALF == 'Second Half' ~ SECONDS_IN_HALF)) %>%
        mutate(HOME_LEAD = HOME_SCORE_DIFF) %>%
        mutate(HOME_LEAD = case_when(HOME_SCORE_DIFF >=14 ~ 'Leading by 14+',
                                     HOME_SCORE_DIFF >=7 & HOME_SCORE_DIFF < 14 ~ 'Leading by 7-13',
                                     HOME_SCORE_DIFF >=3 & HOME_SCORE_DIFF <=7 ~ 'Leading by 3-6',
                                     HOME_SCORE_DIFF > 0 & HOME_SCORE_DIFF < 3 ~ 'Leading by 1-2',
                                     HOME_SCORE_DIFF == 0 ~ 'Tied',
                                     HOME_SCORE_DIFF <=-14 ~ 'Trailing by 14+',
                                     HOME_SCORE_DIFF <=-7 & HOME_SCORE_DIFF >=-14 ~ 'Trailing by 7-13',
                                     HOME_SCORE_DIFF <=-3 & HOME_SCORE_DIFF >=-7 ~ 'Trailing by 3-6',
                                     HOME_SCORE_DIFF < 0 & HOME_SCORE_DIFF >-3 ~ 'Trailing by 1-2'
                                     )) %>%
        mutate(SECONDS_IN_GAME = plyr::round_any(SECONDS_IN_GAME, 10, floor)) %>%
        group_by(HOME_WIN, HOME_LEAD, SECONDS_IN_GAME) %>%
        count() %>%
        arrange(HOME_LEAD, SECONDS_IN_GAME) %>%
        group_by(HOME_LEAD, SECONDS_IN_GAME) %>%
        mutate(prop = n / sum(n)) %>%
        filter(HOME_WIN == 'yes') %>%
        mutate(HOME_LEAD = factor(HOME_LEAD,
                                  levels = c("Leading by 14+",
                                             "Leading by 7-13",
                                             "Leading by 3-6",
                                             "Leading by 1-2",
                                             "Tied",
                                             "Trailing by 1-2",
                                             "Trailing by 3-6",
                                             "Trailing by 7-13",
                                             "Trailing by 14+"))) %>%
        ggplot(., aes(x=SECONDS_IN_GAME,
                      group = HOME_LEAD,
                      color = HOME_LEAD,
                      y = prop))+
        geom_point(alpha=0.5)+
        geom_smooth(formula = 'y ~ x',
                    method = 'loess')+
        coord_cartesian(ylim = c(0, 1))+
        scale_x_reverse()+
        theme_phil()+
        scale_color_manual(values = score_palette)+
        facet_wrap(HOME_LEAD~.)+
        ggtitle("When Does the Home Team Win?",
                str_wrap("Home team win percentage in college football as a function of time remaining and score differential.", 120))+
        guides(fill = "none",
               color = "none")
```

## Creating Recipes

I'll define a recipe to create features and apply preprocessing for the models I'll train.

```{r create recipe for win probability}

baseline_recipe = recipe(HOME_WIN ~.,
                         data = plays_train) %>%
        update_role(all_predictors(),
                    new_role = "id") %>%
        update_role(
                c("GAME_ID",
                  "DRIVE_ID",
                  "PLAY_ID",
                  "SEASON",
                  "ATTENDANCE",
                  "HALF",
                  "PERIOD",
                  "HOME",
                  "HOME_ID",
                  "HOME_CONFERENCE", 
                  "AWAY",
                  "AWAY_ID",
                  "AWAY_CONFERENCE",
                  "OFFENSE",
                  "DEFENSE",
                  "OFFENSE_SCORE",
                  "DEFENSE_SCORE",
                  "PLAY_TEXT",
                  "PLAY_TYPE",
                  "YARD_LINE"),
                new_role = "ID") %>%
        # now filter training set to certain plays
        step_filter(PERIOD %in% c(1,2,3,4)) %>%
       # step_filter(DISTANCE >=0 & DISTANCE <=100) %>%
        step_filter(YARDS_TO_GOAL <=100) %>%
        step_mutate(SPECIALTEAMS = case_when(DOWN == -1 & DISTANCE <0 ~ 'yes',
                                             TRUE ~ 'no')) %>%
        step_mutate(DISTANCE = case_when(DISTANCE < 0 ~ 0,
                                         TRUE ~ DISTANCE)) %>%
        # now select predictors
        # step_mutate(OFFENSE_PREGAME_ELO = case_when(OFFENSE == HOME ~ HOME_PREGAME_ELO,
        #                                             TRUE ~ AWAY_PREGAME_ELO),
        #             DEFENSE_PREGAME_ELO = case_when(OFFENSE == AWAY ~ HOME_PREGAME_ELO,
        #                                             OFFENSE == HOME ~ AWAY_PREGAME_ELO)) %>%
        step_mutate(HOME_SCORE_DIFF = HOME_SCORE - AWAY_SCORE) %>%
        step_mutate(HOME_ELO_DIFF = HOME_PREGAME_ELO - AWAY_PREGAME_ELO) %>%
        # step_mutate(OFFENSE_SCORE_DIFF = OFFENSE_SCORE - DEFENSE_SCORE,
        #             OFFENSE_ELO_DIFF = OFFENSE_PREGAME_ELO - OFFENSE_PREGAME_ELO) %>%
        step_mutate(SECONDS_IN_GAME = case_when(HALF == 'First Half' ~ 1800+SECONDS_IN_HALF,
                                                TRUE ~ SECONDS_IN_HALF)) %>%
        step_mutate(DISTANCE = log1p(DISTANCE)) %>%
        step_mutate(OFFENSE_TIMEOUTS = case_when(OFFENSE_TIMEOUTS < 0 ~ 0,
                                                 TRUE ~ OFFENSE_TIMEOUTS),
                    DEFENSE_TIMEOUTS = case_when(DEFENSE_TIMEOUTS < 0 ~ 0,
                                                 TRUE ~ DEFENSE_TIMEOUTS)) %>%
        step_mutate(OFFENSE_TIMEOUTS = replace_na(OFFENSE_TIMEOUTS, 0),
                    DEFENSE_TIMEOUTS = replace_na(DEFENSE_TIMEOUTS, 0)) %>%
        step_mutate(DOWN = factor(DOWN)) %>%
        # step_mutate(NEUTRAL_SITE = factor(NEUTRAL_SITE,
        #                                   levels = c("no", "yes"))) %>%
        # step_mutate(SPECIALTEAMS = factor(SPECIALTEAMS,
        #                                   levels = c("no", "yes"))) %>%
        update_role(c("PERIOD",
                      "DOWN",
                      "DISTANCE",
                      "YARDS_TO_GOAL",
                      "OFFENSE_TIMEOUTS",
                      "DEFENSE_TIMEOUTS",
                      "NEUTRAL_SITE"),
                    new_role = "predictor") %>%
        # step_novel(all_nominal_predictors(),
        #            new_level = "new") %>%
        step_dummy(all_nominal_predictors()) %>%
        step_normalize(all_numeric_predictors()) %>%
        check_missing(all_predictors())

        # step_interact(terms = ~ DISTANCE:(starts_with("DOWN_"))) %>%
        # step_interact(terms = ~ YARDS_TO_GOAL:(starts_with("DOWN_"))) %>%
        # step_interact(terms = ~ YARDS_TO_GOAL*HOME_SCORE_DIFF) %>%
        # step_interact(terms = ~ YARDS_TO_GOAL*SECONDS_IN_GAME) %>%
        # step_interact(terms = ~ IS_HOME_OFFENSE*SECONDS_IN_GAME) %>%
        # step_interact(terms = ~ HOME_SCORE_DIFF*SECONDS_IN_GAME) %>%
        # step_interact(terms = ~ OFFENSE_TIMEOUTS*SECONDS_IN_GAME) %>%
        # step_interact(terms = ~ DEFENSE_TIMEOUTS*SECONDS_IN_GAME) %>%

foo = baseline_recipe %>% 
        prep(plays_train) %>%
        bake(plays_train %>% sample_n(10000))

```




