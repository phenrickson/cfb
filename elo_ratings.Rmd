---
title: "CFB Elo Ratings"
author: "Phil Henrickson"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE #adds a Table of Contents
    theme: cerulean
    number_sections: TRUE #number your headings/sections
    toc_float: TRUE #let your ToC follow you as you scroll
    keep_md: no
    fig.caption: yes
    css: "styles.css"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = F,
                      error = F,
                      warning=F,
                      dev="png",
                      fig.width = 10,
                      fig.height = 8)

options(knitr.duplicate.label = "allow")

options(scipen=999)

```

```{r connect to snowflake}

library(DBI)
library(odbc)
library(RODBC)
library(keyring)

# connect to snowflake
myconn <- DBI::dbConnect(odbc::odbc(),
                         "SnowflakeDSII",
                         Database = "CFB_DEMO",
                         warehouse = "DEMO_WH",
                         uid="phil.henrickson",
                         pwd=keyring::key_get("AE_Snowflake"))

```

```{r packages, include=F} 

source(here::here("scripts/load_packages.R"))
library(rstan)
library(rstanarm)
library(rstantools)
library(jsonlite)
library(forcats)
conflict_prefer("lag", "dplyr")

```

```{r load functions}

source(here::here("functions/theme_phil.R"))
rm(a)
```

```{r get games}

# get games
games_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.GAMES')) %>%
        as_tibble() %>%
        mutate(ID = as.numeric(ID)) %>%
        rename(GAME_ID = ID)

# recruiting
recruiting_teams_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.RECRUITING_TEAMS')) %>%
        as_tibble()
        
```

# What is this? {-}

This notebook explores creating Elo ratings for college football teams using data from the late 1800s to present.

# The Data

The data we're using is at the game level, in which we have features indicating the season, the week, the location, the teams, and the score. 

```{r game level data for all teams}

set.seed(8)
games_data_raw %>%
        filter(SEASON > 2000 & SEASON < 2017) %>%
        sample_n(5) %>%
        select(GAME_ID, SEASON, WEEK, VENUE, HOME_TEAM, AWAY_TEAM, HOME_POINTS, AWAY_POINTS) %>%
        mutate(HOME_WIN = case_when(HOME_POINTS > AWAY_POINTS ~ 'yes',
                                    TRUE ~ 'no')) %>%
        mutate(GAME_ID = as.character(GAME_ID),
               SEASON = as.character(SEASON)) %>%
        flextable() %>%
        autofit()

```

We also have additional features on team conferences, attendance, start time, betting line, as well as information from an existing Elo Model. We'll set that aside for now, as our goal here is to go through the process of developing our own Elo model. 

We lose some information the further we go back, but we have outcomes of games back to the very first game between Rutgers and Princeton in 1869.

```{r get outcomes since 1869}

games_data_raw %>%
        group_by(SEASON) %>%
        summarize(n_games = n_distinct(GAME_ID)) %>%
        ggplot(., aes(x=SEASON,
                      y=n_games))+
        geom_col()+
        theme_phil()

```

# Elo Ratings

What exactly is an Elo rating? It takes its name from the guy who first came up with the idea, Arpad Elo, who developed it for the purpose of ranking chess players: https://en.wikipedia.org/wiki/Elo_rating_system. I note this because people commonly refer to these as ELO scores - no, it's Elo, it's from his name.

The basic idea is to, for any given matchup between opponents, assign a rating to each opponent that can be used to predict the outcome of the match. The result of the match will then influence their ensuing ratings, with the winner gaining points from the loser. An opponent's rating is always a function of prior results, taking into account their performance in previous matches as well as the ratings of their opponents. 

## The Expected Score

For the full description of how this works, check out the Wikipedia page, but I'll paraphrase it here to the best of my ability. Say we've got an upcoming match between two opponents, $A$ and $B$. In an Elo rating system, the expected result, or score, for Opponent $A$ in a match against Opponent $B$ is: $$E_A = \frac{1}{1+10^{(R_B-R_A)/V}}$$

What does this equation mean?

* $E_A$ is Opponent's A expected score from the match - in the case of matchup between two opponents, this basically just reduces to win probability.

* $R_A$ is Opponent A's pre match rating

* $R_B$ is Opponent B's pre match rating

* 10 is the base value used in the rating system; typically 10 is used in these types of ratings

* V is a scaling factor that sets how much a difference in rating between the two opponents will affect the probability of either side winning. More on this in a second.

How did we get this equation? It's just a logistic curve of the form $f(x) = \frac{1}{1+e^{-x}}$, which is the standard logistic function with a growth rate and curve maximum of 1. Don't worry about this too much, it basically just constrains any input of x to return a number between 0 and 1.

Similarly, the expected score for Opponent B is: $$E_B = \frac{1}{1+10^{(R_A-R_B)/V}}$$

What's the point of this equation? We can input ratings for $A$ and $B$ and get back an expected score for an opponent based on the difference between the two opponent's rating.

```{r write a function for elo, echo=T}

get_expected_score <- function(R_A, R_B, V=400) {
        
        return(1 / (1 + 10^((R_B - R_A) / V)))
        
        }

```

If the two opponents have equal ratings, the difference between their rating is zero, and the the expected score reduces to 0.5. Why? When the difference is zero, anything raised to the 0 is 1, and the scaling factor no longer matters:  $$E_A = \frac{1}{1+10^{0/V}} = \frac{1}{1+1} = \frac{1}{2}$$

So, anytime we have two perfectly equal opponents, the expected score reduces to a coin flip.

Okay, but now suppose that $R_A$ is 100 and $R_B$ is 50 and $V$ is 200. Plugging these numbers into the equation above, we get an expected score for A of `r round(get_expected_score(R_A = 100, R_B = 50, V = 200), 4)`. In this case, $A$ is more likely to win, as they have a higher rating. In this case, the scaling factor $V$ determines how much the difference in rating matters for the expected score:

$$E_A = \frac{1}{1+10^{(50-100)/200}} = \frac{1}{1+10^{-50/200}} = \frac{1}{1+10^{-1/4}} \approx \frac{1}{1+.5623}  \approx  0.64$$
If the scaling factor $V$ was set to 50, the difference in rating between these two teams would be considered much bigger.

$$E_A = \frac{1}{1+10^{(50-100)/50}} = \frac{1}{1+10^{-50/50}} = \frac{1}{1+10^{-1}} \approx \frac{1}{1+.0.1}  \approx  0.909$$
Tangibly, this means the scaling factor indicates the difference at which one opponent's expected score would be ten times greater than their opponent's expected score. I'll plot the expected score for $A$ as a function of the difference between $R_B$ and $R_A$ using different values of $V$ for the scaling factor.

```{r test the func}

a_vals = seq(0, 100, 1)
b_vals = rep(50, length(a_vals))
v_vals = c(5, 10, 25, 50, 100)

foo = foreach(i=1:length(a_vals), .combine=bind_rows) %:% 
        foreach(j = 1:length(v_vals), .combine=bind_rows) %do% {
        
        get_expected_score(a_vals[i],
                           b_vals[i],
                           v_vals[j]) %>%
                        as_tibble() %>%
                        mutate(diff = a_vals[i]-b_vals[i],
                               v = v_vals[j])
        }

# plot
foo %>%
        mutate(v = as.factor(v)) %>%
        ggplot(., aes(x=diff,
              color = v,
              group = v,
             y=value))+
        geom_line(lwd=1.1)+
        theme_bw()+
        xlab("Rating B - Rating A")+
        ylab("Expected Score A")+
        scale_color_viridis_d()

rm(foo)

```
All this is to say that the selection of the scaling factor and the initial Elo values determine the scaling of the ratings, and we can make decisions about these. 

## Updating Elo Ratings

But none of this so far gets to the real heart of why Elo ratings prove to be useful, which is that they are always updating based on new results.  After a match between opponents, the outcome of the match determines each opponent's updated rating.

As we said earlier, before the match, $R_A$ is 100 and $R_B$ is 50 and $V$ is 200. After the match, we recalculate each opponent's score taking into account what happened in the match. How do we do this? The equation looks like this:

$$R'_A = R_A + K*(S_A - E_A)$$
We update $R'_A$ based on the previous rating plus the difference between what they actually scored $S_A$ minus what they were expected to score $E_A$, multiplied by the $K$-factor, which determines the maximum possible adjustment between games.

Let's say that that $A$ lost the match to $B$. Their initial score was 100. If the k-factor is set to 10, the most their score could drop is 10 points. They will drop by slightly less than that, based on their expected score:

$$R'_A = 100 + 10*(0 - 0.64) \approx 93.6$$
$B$, on the other hand, would get a boost to their rating.

$$R'_B = 50 + 10*(1 - 0.36) \approx 56.4$$

In this way, the winner picks up points from the loser, and $K$ determines how many points can be transferred in one match

## Margin of Victory

The original Elo rating updated didn't take into account the margin of victory by the winner, effectively treating close losses and blowouts as the same result. Fortunately, we can make a slight change to the formula for updating ratings in order to account for the margin of victory by the winner. I'm adapting the approach I'll try out here after the methodology described at https://fivethirtyeight.com/methodology/how-our-nfl-predictions-work/

How do we account for the margin of victory in updating the rating? We add a multiplier $M$ based on the margin of victory for the winner in addition to the K factor: 

$$R'_A = R_A + M*K*(S_A - E_A)$$

538 uses a margin of victory multiplier in their ratings that looks like this:

$$ M = MarginMulti = ln(WinnerPointDiff + 1) * Adjustment$$
Ignore the adjustment piece for a second. The idea is to multiply the result of the game by taking the natural log of the winner's point differential + 1 (as ln(0) is undefined). When the point differential is zero, the margin multiplier reduces to 0 and there is no multiplier. When the differential is positive the winner gets more points from their opponent based on how much they won by, with diminishing credit the further out we go in the margin of victory.

```{r plot of margin of victory}

tibble(x = seq(0, 50),
       y = log(x+1)) %>%
        ggplot(., aes(x=x,
                      y=y))+
        geom_line()+
        theme_phil()+
        xlab("x")+
        ylab("log(x+1)")

```

What about that adjustment? 538 discusses adjusting for autocorrelation, which is correlation within a time series between its current and past values. In the case of Elo ratings, if we only include a margin multiplier, we will quickly find that teams that are winning a lot are also winning by high margins. This means we'll end up with a positive feedback loop for winning teams which, lacking any sort of adjustment, can lead to inflated ratings for good teams.

538 suggest adjusting for this based around the difference in pre game Elo between the two teams. 

$$ Adjustment = \frac{2.2}{WinnerEloDiff*0.001+2.2}$$
Let's continue to say that $A$'s pre game Elo rating is 100 and $B$'s is 50. We'll keep $V$ at 200 and $K$ at 10, as before. But let's now say that $A$ lost the match by 7 points in the game. This makes the margin of victory multiplier:

$$M = log(7+1)*\frac{2.2}{-50*0.001+2.2} \approx 2.13$$

Which we then plug in for M in their updated rating formula, which becomes:

$$R'_A = 100 + 2.13*10*(0 - 0.64) \approx 87.01$$
If $A$ had only lost by one point, the margin of victory multiplier would decrease:

$$M = log(1+1)*\frac{2.2}{-50*0.001+2.2} \approx 0.709 $$

and $A$'s updated rating would become:

$$R'_A = 100 + 0.709*10*(0 - 0.64) \approx 95.46$$
Functionally, this means that the margin of victory multiplier will kick in more depending on whether you're the pre game favorite or not. This means if you win by a lot as the favorite, you won't necessarily pick up more points, but if you lose by a lot as the favorite you can take a serious hit to your points.

Here's what $A$'s updated rating would look like as a function of the margin of victory for the winner in the event of a win or a loss.

```{r update rating function, echo=T}

update_team_rating <- function(team_rating,
                               opponent_rating,
                               observed_score,
                               winner_mov,
                               expected_score,
                               k_factor = 10) {
        
        if (observed_score == 1) {
                mov_multi = log(winner_mov+1) * (2.2 / (((team_rating - opponent_rating)*0.001) + 2.2))
        } else if (observed_score ==0) {
                mov_multi = log(winner_mov+1) * (2.2 / (((opponent_rating - team_rating)*0.001) + 2.2))
        } else {
                 mov_multi = 2.2*log(2)
        }
        
        # multiplier for margin of victory

         # now compute updated rating taking into account initial rating and mov
         updated_rating = 
                 team_rating + 
                 (mov_multi *
                          k_factor * 
                          (observed_score - expected_score))
         
         return(updated_rating)
         
}

mov = seq(1, 50)
outcome = c(0,1)
a = 100
b = 50
v = 200

win_mov = foreach(i = 1:length(mov),
                  .combine = bind_rows) %:%
        foreach(j = 1:length(outcome),
                .combine = bind_rows) %do% {
                          
                           a_update = update_team_rating(
                                   team_rating = a,
                                   opponent_rating = b,
                                   observed_score  = outcome[j],
                                   winner_mov = mov[i],
                                   expected_score = get_expected_score(a, b, v),
                                   k_factor = 10) %>%
                                   tibble(updated_rating = .,
                                          team = 'A',
                                          outcome = outcome[j],
                                          mov = mov[i])
                           
                           b_update = update_team_rating(
                                   team_rating = b,
                                   opponent_rating = a,
                                   observed_score  = outcome[j],
                                   winner_mov = mov[i],
                                   expected_score = get_expected_score(b, a, v),
                                   k_factor = 10) %>%
                                   tibble(updated_rating = .,
                                          team = 'B',
                                          outcome = outcome[j],
                                          mov = mov[i])
                           
                           bind_rows(a_update, b_update)

}

# look at A's updated rating as a function of the margin of victory
win_mov %>%
        mutate(outcome = case_when(outcome == 0 & team=='A' ~ 'B win',
                                   outcome == 1 & team == 'B' ~ 'B win',
                                   outcome == 0 & team == 'B' ~ 'A win',
                                   outcome == 1 & team == 'A' ~ 'A win')) %>%
        mutate(mov = case_when(outcome == 'B win' ~ -mov,
                               outcome == 'A win' ~ mov)) %>%
        ggplot(., aes(x=mov,
                      color = team,
                      y=updated_rating))+
        geom_line()+
        theme_phil()+
        geom_hline(yintercept = 100,
                   color = 'red',
                   linetype = 'dashed')+
        xlab("Score A - Score B")+
        ylab("Updated Elo Rating")+
        scale_color_manual(values = c("red", "blue"))+
                geom_hline(yintercept = 50,
                   color = 'blue',
                   linetype = 'dashed')

```

If $A$, the pre game favorite, wins by 50, the most they can really move up is 10 points (in this case, the K factor). If $A$ loses by 50 as the favorite, they can drop nearly 25. 

What's with the constants of 2.2 and 0.001? As far as I can tell, this is because they initialized their ratings for teams at around 1500 (others have less) and they expect the maximum difference in Elo to be no greater than 2200 (2.2 / 0.001). The equation itself no longer works if the WinnerEloDiff is -2200, as the denominator goes to zero. The decision for these constants should then depend on the scale factor and the initial ratings selected.

```{r remove}

rm(a_update,
   b_update,
   win_omv,
   a,
   b,
   a_vals,
   b_vals,
   mov,
   outcome)

```


# Elo Ratings and Historical CFB Games

## Initial Settings: 1970-1990

Okay, so at this point we have what we need in order to build out Elo Ratings for college football games. We could start this analysis going back all the way to 1869 as the starting point, but I'll start at 1970 for now since I'm at least somewhat familiar with teams in this era and will be able to eyeball the results.

I'll set every team FBS's initial rating to 1500, non FBS teams to 1200, and the scaling factor to 400. The appropriate value for K is something that I'll want to explore empirically, but I'll start it at 25 and go from there. 

Let's run from 1970 to 1990 to see how the results change each team's Elo rating over the course of a decade.

```{r look at all teams in games from 1950}

# get universe of games
games_data = games_data_raw %>%
        filter(SEASON >=1970 & SEASON <=1990) %>%
        select(GAME_ID, SEASON, WEEK, VENUE, HOME_TEAM, AWAY_TEAM, HOME_CONFERENCE, AWAY_CONFERENCE, HOME_POINTS, AWAY_POINTS, NEUTRAL_SITE) %>%
        mutate(OUTCOME = case_when(HOME_POINTS > AWAY_POINTS ~ 1,
                                   HOME_POINTS == AWAY_POINTS ~ 0.5,
                                   HOME_POINTS < AWAY_POINTS ~ 0)) %>%
        arrange(SEASON, WEEK, GAME_ID)

# now get this at the team level
team_games = games_data %>%
        select(SEASON, GAME_ID, WEEK, HOME_TEAM, HOME_CONFERENCE) %>%
        rename(TEAM = HOME_TEAM,
               CONFERENCE = HOME_CONFERENCE) %>%
        bind_rows(., games_data %>%
                          select(SEASON, GAME_ID, WEEK, AWAY_TEAM, AWAY_CONFERENCE) %>%
                          rename(TEAM = AWAY_TEAM,
                                 CONFERENCE = AWAY_CONFERENCE)) %>%
        arrange(SEASON, WEEK, GAME_ID)

# define initial team elo ratings
initial_team_elo_ratings = team_games %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        group_by(TEAM) %>%
        filter(SEASON == min(SEASON)) %>%
        filter(WEEK == min(WEEK)) %>%
        ungroup() %>%
        mutate(TYPE = "Pre_Elo") %>%
        mutate(TEAM_ELO = case_when(!is.na(CONFERENCE) ~ 1500,
                            TRUE ~ 1200)) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO, CONFERENCE)

```

This means we loop over every game, look at the result, and then update each team's Elo rating based on the outcome and the margin of victory. 

```{r create initial function}

# define function to calculate elo ratings
calc_elo_ratings = function(input_game_matchups,
                            input_team_games,
                            input_initial_team_elo_ratings,
                            k,
                            v) {
        
        # get game ids 
        game_ids = input_game_matchups %>%
                arrange(SEASON, WEEK, GAME_ID) %>%
                select(GAME_ID) %>%
                unique() %>%
                pull(GAME_ID)
        
        # define
        team_elo_ratings = input_initial_team_elo_ratings
        
        # now loop over games and get results
        elo_game_results = foreach (i = 1:length(game_ids), 
                                    .combine = bind_rows) %do% {
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                                           filter(GAME_ID == game_ids[i]) %>%
                                           filter(TEAM == away_team) %>%
                                           filter(TYPE == 'Pre_Elo') %>%
                                           pull(TEAM_ELO)
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                home_expected_score = get_expected_score(home_team_pre_elo,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo, 
                                                         V = v)
                
                ## now look at the outcome
                # get the outcome
                home_team_outcome = input_game_matchups %>% 
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(OUTCOME)
                
                # get the margin of victory for the winner
                winner_margin = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        mutate(WIN_MARGIN = abs(HOME_POINTS-AWAY_POINTS)) %>%
                        pull(WIN_MARGIN)
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating(team_rating = home_team_pre_elo,
                                                        opponent_rating = away_team_pre_elo,
                                                        observed_score = home_team_outcome,
                                                        winner_mov = winner_margin,
                                                        expected_score = home_expected_score,
                                                        k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating(team_rating = away_team_pre_elo,
                                                        opponent_rating = home_team_pre_elo,
                                                        observed_score = 1-home_team_outcome,
                                                        winner_mov = winner_margin,
                                                        expected_score = away_expected_score,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON),
                               WEEK =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                         SEASON =  input_game_matchups %>%
                                              filter(GAME_ID == game_ids[i]) %>%
                                              pull(SEASON),
                        WEEK =  input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_POINTS = input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(HOME_POINTS),
                        AWAY_POINTS = input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(AWAY_POINTS),
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome) %>%
                        mutate(K = k,
                               V = v)
                
                game_result

                                    }
        
        
        # return 
        out = list(
                "elo_game_results" =  elo_game_results,
                "elo_team_ratings" = team_elo_ratings %>%
                        mutate(K = k,
                               V = v))
        
        # return
        return(out)
        
}
        

```


```{r now run initial elo results v1, include=F}

elo_ratings_returned = calc_elo_ratings(input_game_matchups = games_data,
                                        input_team_games = team_games,
                                        input_initial_team_elo_ratings = initial_team_elo_ratings,
                                        k=25,
                                        v = 400)

```

```{r grab the results}

team_elo_ratings = elo_ratings_returned$elo_team_ratings
elo_game_results = elo_ratings_returned$elo_game_results

```

### SEC 

Once that finishes, we have the accumulation of Elo ratings as a function of game outcomes over the selected time period. For instance, here is how each SEC team's Elo ratings fared from 1970-1980.

```{r get initial and updated for SEC v1}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'SEC') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### Big Ten

```{r get initial and updated for big 10 v1}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'Big Ten') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### SWC

```{r get initial and updated for southwest v1}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'Southwest') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### Results

We can then look at the log loss over the course of each season. Using the expected score from the Elo ratings, how do we perform in predicting the outcomes of games? I'll compare the result of the Elo ratings to a baseline model that assigns the home team a 60% chance of winning. 

```{r log loss by week by season}

int_breaks <- function(x, n = 5) {
  l <- pretty(x, n)
  l[abs(l %% 1) < .Machine$double.eps ^ 0.5] 
}

# log loss
elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        mn_log_loss(truth = HOME_WIN,
                    estimate = HOME_PROB,
                    event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        bind_rows(.,
                  elo_game_results %>%
                          mutate(HOME_PROB = .6) %>%
                          mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                                             TRUE ~'no'))) %>%
                          group_by(SEASON) %>%
                          mutate(games = n_distinct(GAME_ID)) %>%
                          group_by(SEASON, games) %>%
                          mn_log_loss(truth = HOME_WIN,
                                    estimate = HOME_PROB,
                                    event_level = 'second') %>%
                          mutate(Model = 'Home Win')
                  ) %>%
        ggplot(., aes(x=SEASON,
                      color = Model,
                      y=.estimate,
                      size = games))+
        geom_point()+
        geom_line(lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.2)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("log-loss")+
        scale_color_manual(values = c("deepskyblue1",
                                      "grey40"))+
        ggtitle("Average Log-Loss by Season")+
        coord_cartesian(ylim = c(0, 1))

```

As we would hope, the Elo ratings outperform simply predicting that the home team will win.

We can also just look at the number of games correctly predicted, and find similar results.

```{r by each}

# log loss
elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        yardstick::accuracy(truth = HOME_WIN,
                            estimate = HOME_PRED,
                            event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        bind_rows(.,
                  elo_game_results %>%
                          mutate(HOME_PRED = factor('yes',
                                                    levels = c("no", "yes"))) %>%
                          mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                                             TRUE ~'no'))) %>%
                          group_by(SEASON) %>%
                          mutate(games = n_distinct(GAME_ID)) %>%
                          group_by(SEASON, games) %>%
                          yardstick::accuracy(truth = HOME_WIN,
                                    estimate = HOME_PRED,
                                    event_level = 'second') %>%
                          mutate(Model = 'Home Win')
                  ) %>%
        ggplot(., aes(x=SEASON,
                      color = Model,
                      y=.estimate,
                      size = games))+
        geom_point()+
        geom_line(lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Accuracy")+
        scale_color_manual(values = c("deepskyblue1",
                                      "grey40"))+
        ggtitle("Average Accuracy by Season")+
        coord_cartesian(ylim = c(0, 1))

```

Similarly, log loss by the week of each season.

```{r log loss by week}

elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(SEASON, WEEK) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, WEEK, games) %>%
        yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        bind_rows(.,
                  elo_game_results %>%
                          mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
                          mutate(HOME_PROB = .6) %>%
                          group_by(SEASON, WEEK) %>%
                          mutate(games = n_distinct(GAME_ID)) %>%
                          group_by(SEASON, WEEK, games) %>%
                          yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
                          mutate(Model = 'Home Win'),
                  )  %>%
        ggplot(., aes(x=WEEK,
                      group = Model,
                      color = Model,
                      by = SEASON,
                      y=.estimate))+
        geom_point(aes(size = games),
                   alpha = 0.5)+
        geom_smooth(
                  stat = 'smooth',
                  method = 'loess',
                  se=F,
                  formula = 'y ~ x')+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Log Loss")+
        scale_color_manual(values = c("deepskyblue1",
                                      "grey40"))+
        ggtitle("Average Log-Loss by Week")+
        coord_cartesian(ylim = c(0, 1))

```

### Point Spread

A nice feature of the Elo rating framework is that it also extends to predicting the point differential. Here is home team's scoring margin (Home Points - Away Points) as a function of the home team's Elo diff (Home Pre Elo - Away Pre Elo).

```{r we can also look at the predicted spread vs the actual}

elo_game_results %>%
        mutate(HOME_ELO_DIFF = HOME_PRE_ELO - AWAY_PRE_ELO) %>% 
  #      mutate(HOME_PRED_SCORE_DIFF = HOME_ELO_DIFF / 25)
        mutate(HOME_SCORE_DIFF = HOME_POINTS-AWAY_POINTS) %>% 
        ggplot(., aes(x=HOME_ELO_DIFF, y=HOME_SCORE_DIFF))+
        geom_point()+
        facet_wrap(SEASON ~., ncol =6) + 
        theme_phil()+
        geom_vline(xintercept =0,
                   linetype = 'dotted')+
        geom_hline(yintercept =0,
                   linetype = 'dotted')+
        geom_smooth(method = 'lm',
                    formula = 'y ~ x')+
        ggtitle("Predicted Point Spread via Pre Game Elo Scores")

```

The relationship changes over the years, as the initial few seasons are being used to learn the Elo scores, but once we have a few seasons worth of data the partial effect of a point change in Elo differential on the score differential seems to be around .05 - this means tangibly that a 20 point lead in Elo is worth about a point on the spread; a 200 point lead is worth about 10 points.

```{r predicted margin}

pre_elo_diffs = tibble(HOME_PRE_ELO_DIFF = seq(-500, 500, 5))

# fit a linear model of the point differential on the elo ratings
foo = elo_game_results %>%
        mutate(HOME_PRE_ELO_DIFF = HOME_PRE_ELO - AWAY_PRE_ELO) %>% 
        #mutate(HOME_PRED_SCORE_DIFF = HOME_ELO_DIFF / 25)
        mutate(HOME_SCORE_DIFF = HOME_POINTS-AWAY_POINTS) %>% 
        nest(-SEASON) %>%
        mutate(lm = map(data, 
                        ~ lm(HOME_SCORE_DIFF ~ HOME_PRE_ELO_DIFF,
                             data = .x))) %>%
        mutate(tidied = map(lm, tidy, se="robust", conf.int=T)) %>%
        mutate(pred = map(lm, ~ .x %>% predict(pre_elo_diffs,
                                        interval = 'prediction') %>%
                                  bind_cols(., pre_elo_diffs))) %>%
        mutate(confidence = map(lm, ~ .x %>% predict(pre_elo_diffs,
                                        interval = 'confidence') %>%
                                  bind_cols(., pre_elo_diffs)))

# coef
foo %>%
        select(SEASON, tidied) %>%
        unnest() %>%
        filter(term == 'HOME_PRE_ELO_DIFF') %>%
        ggplot(., aes(x=SEASON,
                      y=estimate,
                      ymin = conf.low,
                      ymax = conf.high))+
        geom_point()+
        geom_pointrange()+
        theme_phil()+
        coord_cartesian(ylim = c(0, NA))+
        geom_hline(yintercept = 0,
                   linetype = 'dashed')+
        geom_hline(yintercept = 0.05,
                   linetype = 'dotted',
                   color ='grey60')

# # predicted spread
# foo %>%
#         select(SEASON, pred) %>%
#         unnest() %>%
#         mutate(interval = 'prediction') %>%
#         bind_rows(.,
#                   foo %>%
#                           select(SEASON, confidence) %>%
#                           unnest() %>%
#                           mutate(interval = 'confidence')) %>%
#         filter(HOME_PRE_ELO_DIFF == 100) %>%
#         mutate(type = 'Home Elo - Away Elo = 100') %>%
#    #     filter(HOME_PRE_ELO_DIFF == 500)
#         ggplot(., aes(x=SEASON,
#                       y=fit,
#                       fill = interval,
#                       color = interval,
#                       ymin = lwr,
#                       ymax = upr))+
#         geom_line()+
#         geom_ribbon(alpha = 0.5)+
#         theme_phil()+
#         facet_wrap(type ~.)+
#         geom_hline(yintercept = 0,
#                    linetype = 'dashed')

```

We can simulate the point differential and compare it to the actual. I'll look at the 1980 season, week by week to see the simulated result vs actual.

```{r simulate and compare point differential}

set.seed(2)
foo %>% 
        filter(SEASON == 1980) %>%
        mutate(sim = map(lm, simulate)) %>% 
        select(SEASON, data, sim) %>% 
        unnest() %>% 
        mutate(sim_1 = round(sim_1, 0)) %>%
        mutate(HOME_SCORE_DIFF_char = case_when(HOME_SCORE_DIFF > 0 ~ paste("+", HOME_SCORE_DIFF, sep=""),
                                    HOME_SCORE_DIFF == 0 ~ paste("Tie"),
                                    HOME_SCORE_DIFF < 0 ~ paste(HOME_SCORE_DIFF, sep=""))) %>%
        mutate(sim_char = case_when(sim_1 > 0 ~ paste("+", sim_1, sep=""),
                                    sim_1 == 0 ~ paste("Tie"),
                                    sim_1 < 0 ~ paste(sim_1, sep="")),
               GAME = paste(HOME_TEAM, " ", AWAY_TEAM, "\n",
                            "Actual.:", HOME_TEAM,  HOME_SCORE_DIFF_char, "\n",
                            "Sim:", HOME_TEAM, sim_char, sep="")) %>%
        mutate(CORRECT = case_when(sim_1 >0 & HOME_SCORE_DIFF >0 ~ 'yes',
                                   sim_1 <0 & HOME_SCORE_DIFF <0 ~ 'yes',
                                   TRUE ~ 'no')) %>%
        ggplot(., aes(x=HOME_SCORE_DIFF,
                      color = CORRECT,
                      label = GAME,
                      y=sim_1))+geom_point()+
        geom_text(check_overlap=T, 
                  vjust=-0.5, size=2)+
        theme_phil()+
        scale_color_manual(values = c("red", "blue"))+
        facet_wrap(SEASON + WEEK~.,
                   ncol = 4)+
        geom_vline(xintercept =0,
                   linetype = 'dotted')+
        geom_hline(yintercept = 0,
                   linetype = 'dotted')

```

I'll save the Elo ratings computed with these settings so we can see how they compare with changes to the parameters/methodology.

```{r save v1 results}

elo_ratings_returned_v1 = elo_ratings_returned

rm(team_elo_ratings,
   elo_game_results,
   elo_ratings_returned)

```


## Initial Settings + Mean Reversion: 1970-1990

As it's constructed so far, the Elo ratings for a team in one season pick up right from where they left off in the previous season. This is particularly an issue in the world college football, given that players graduate and turnover in rosters year over year is high. We shouldn't expect, in other words, a team at the beginning of its 1980 season to be the exact same as it ended its 1979 season.

Currently, our Elo ratings do not reset in anyway, and this means we ended up being a little bit worse at the beginning of each season.

```{r show results by week by season}

elo_ratings_returned_v1$elo_game_results %>%
        filter(SEASON != 1970) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(SEASON, WEEK) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, WEEK, games) %>%
        yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        ggplot(., aes(x=WEEK,
                      by = SEASON,
                      y=.estimate))+
        geom_point(aes(size = games),
                   alpha = 0.5,
                   color = 'deepskyblue1')+
        geom_smooth(
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x')+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Log Loss")+
        # scale_color_manual(values = c("deepskyblue1",
        #                               "grey40"))+
        ggtitle("Average Log-Loss by Week")+
        coord_cartesian(ylim = c(0, 1))

```

We can handle this by regressing each team back to the mean at the start of each season. I'll apply a 1/4 weight back to 1500 for FBS teams and a 1/4 weight back to 1200 for non FBS teams between seasons.

```{r now re run with mean reversion}

calc_elo_ratings_with_reversion = function(input_game_matchups,
                            input_team_games,
                            input_initial_team_elo_ratings,
                            k,
                            v,
                            reversion = 1/4) {
        
        # get game ids 
        game_ids = input_game_matchups %>%
                arrange(SEASON, WEEK, GAME_ID) %>%
                select(GAME_ID) %>%
                unique() %>%
                pull(GAME_ID)
        
        # define
        team_elo_ratings = input_initial_team_elo_ratings
        
        # now loop over games and get results
        elo_game_results = foreach (i = 1:length(game_ids), 
                                    .combine = bind_rows) %do% {
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                                           filter(GAME_ID == game_ids[i]) %>%
                                           filter(TEAM == away_team) %>%
                                           filter(TYPE == 'Pre_Elo') %>%
                                           pull(TEAM_ELO)
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                home_expected_score = get_expected_score(home_team_pre_elo,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo, 
                                                         V = v)
                
                ## now look at the outcome
                # get the outcome
                home_team_outcome = input_game_matchups %>% 
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(OUTCOME)
                
                # get the margin of victory for the winner
                winner_margin = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        mutate(WIN_MARGIN = abs(HOME_POINTS-AWAY_POINTS)) %>%
                        pull(WIN_MARGIN)
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating(team_rating = home_team_pre_elo,
                                                        opponent_rating = away_team_pre_elo,
                                                        observed_score = home_team_outcome,
                                                        winner_mov = winner_margin,
                                                        expected_score = home_expected_score,
                                                        k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating(team_rating = away_team_pre_elo,
                                                        opponent_rating = home_team_pre_elo,
                                                        observed_score = 1-home_team_outcome,
                                                        winner_mov = winner_margin,
                                                        expected_score = away_expected_score,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON),
                               WEEK =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                # revert new pre elo meetings to mean if new season
                new_pre_elo_ratings = new_pre_elo_ratings %>%
                        mutate(NEW_SEASON = case_when(SEASON > games_data %>% 
                                                              filter(GAME_ID == game_ids[i]) %>%
                                                              pull(SEASON) ~ T,
                                                      TRUE ~ F)) %>%
                        mutate(TEAM_ELO = case_when(
                                (NEW_SEASON == T & is.na(CONFERENCE)) ~ (reversion)*1200 + (1-reversion)*TEAM_ELO,
                                (NEW_SEASON == T & !is.na(CONFERENCE)) ~ (reversion)*1500 + (1-reversion)*TEAM_ELO,
                               TRUE ~ TEAM_ELO))
                
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                         SEASON =  input_game_matchups %>%
                                              filter(GAME_ID == game_ids[i]) %>%
                                              pull(SEASON),
                        WEEK =  input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_POINTS = input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(HOME_POINTS),
                        AWAY_POINTS = input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(AWAY_POINTS),
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome) %>%
                        mutate(K = k,
                               V = v)
                
                game_result

                                    }
        
        
        # return 
        out = list(
                "elo_game_results" =  elo_game_results,
                "elo_team_ratings" = team_elo_ratings %>%
                        mutate(K = k,
                               V = v))
        
        # return
        return(out)
        
}

```

We'll now run this to see how it does.

```{r run with mean reversion}

elo_ratings_returned = calc_elo_ratings_with_reversion(input_game_matchups = games_data,
                                        input_team_games = team_games,
                                        input_initial_team_elo_ratings = initial_team_elo_ratings,
                                        k=25,
                                        v = 400,
                                        reversion = 1/4)

```

```{r grab the results of v2}

team_elo_ratings = elo_ratings_returned$elo_team_ratings
elo_game_results = elo_ratings_returned$elo_game_results
```


### SEC

Let's look again at SEC teams over this time period - we should see them tighen up at the beginning of each season.

```{r now plot SEC with mena reversion}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'SEC') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### Compare Mean Reverting to Initial Ratings

I'll now compare the unadjusted ratings to the updated ratings that include mean reversion. The difference is very slight, and its entirely possible that it's not significant, but we do see slightly better results as the seasons wear on using a beginning of season adjustment. I could do like, a Wald test, to compare the two formally, but who has time for that.

```{r compare log loss between versions}

# log loss
elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        mn_log_loss(truth = HOME_WIN,
                    estimate = HOME_PROB,
                    event_level = 'second') %>%
        mutate(Model = 'Elo Mean Reversion') %>%
        bind_rows(
                elo_ratings_returned_v1$elo_game_results %>%
                        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        mn_log_loss(truth = HOME_WIN,
                    estimate = HOME_PROB,
                    event_level = 'second') %>%
        mutate(Model = 'Elo')) %>%
        ggplot(., aes(x=SEASON,
                      color = Model,
                      y=.estimate,
                      size = games))+
        geom_point()+
        geom_line(lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.2)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("log-loss")+
        scale_color_manual(values = c("deepskyblue1",
                                      "navy"))+
        ggtitle("Average Log-Loss by Season")+
        coord_cartesian(ylim = c(0, 1))

```

Hmmm. We end up with pretty similar results overall.

```{r show results by week by season with updated version}

elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(SEASON, WEEK) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, WEEK, games) %>%
        yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
        mutate(Model = 'Elo Mean Reversion') %>%
        bind_rows(.,
                elo_ratings_returned_v1$elo_game_results %>%
                mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
                mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
                group_by(SEASON, WEEK) %>%
                mutate(games = n_distinct(GAME_ID)) %>%
                group_by(SEASON, WEEK, games) %>%
                yardstick::mn_log_loss(truth = HOME_WIN,
                                    estimate = HOME_PROB,
                                    event_level = 'second') %>%
                mutate(Model = 'Elo')) %>%
        ggplot(., aes(x=WEEK,
                      group = Model,
                      color = Model,
                      by = SEASON,
                      y=.estimate))+
        geom_point(aes(size = games),
                   alpha = 0.5)+
        geom_smooth(
                  stat = 'smooth',
                  method = 'loess',
                  se=F,
                  formula = 'y ~ x')+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Log Loss")+
         scale_color_manual(values = c("deepskyblue1",
                                       "navy"))+
        ggtitle("Average Log-Loss by Week")+
        coord_cartesian(ylim = c(0, 1))

```

```{r save v2}

elo_ratings_returned_v2 = elo_ratings_returned

rm(team_elo_ratings,
   elo_game_results,
   elo_ratings_returned)

```

## Initial Settings + Mean Reversion + Home Team Advantage: 1970-1990

I've seen other Elo rating systems explicitly add points to teams that are at home as a means of accounting for home field advantage. Right now, I'm not doing that, so we should expect to see the home team outperform their Elo rating. Is that the case? I'll look at the performance of the predictions from each of the models so far.

```{r results by home team}

class_metrics = metric_set(yardstick::precision,
                           yardstick::recall,
                           yardstick::f_meas,
                           yardstick::accuracy,
                           yardstick::bal_accuracy,
                           yardstick::kap,
                           yardstick::npv,
                           yardstick::ppv)

elo_ratings_returned_v1$elo_game_results %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        yardstick::conf_mat(HOME_WIN, HOME_PRED, dnn = c("Home Pred", "Home Win"))

elo_ratings_returned_v2$elo_game_results %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        yardstick::conf_mat(HOME_WIN, HOME_PRED, dnn = c("Home Pred", "Home Win"))


# bind together
bind_rows(
elo_ratings_returned_v1$elo_game_results %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        mutate(Model = 'Elo'),
elo_ratings_returned_v2$elo_game_results%>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        mutate(Model = 'Elo Mean Reversion')) %>%
        group_by(Model, K, V) %>%
        class_metrics(truth = HOME_WIN,
                      estimate = HOME_PRED) %>%
        mutate_if(is.numeric, round, 3) %>%
        flextable() %>%
        autofit()

```

The Elo ratings with mean reversion are basically the same overall, though both versions tend to do better when predicting that the home team will win (PPV). When the models predict that the home team will lose, they don't do as well (NPV). Home teams win slightly more than we would expect.

```{r look at probs for home vs away along with classification}

elo_ratings_returned_v2$elo_game_results %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        mutate(Model = 'Elo Mean Reversion') %>%
        ggplot(., aes(x=HOME_PROB,
                      fill = HOME_WIN))+
        geom_histogram(bins = 100)+
        facet_wrap(HOME_WIN + Model ~.,
                   ncol = 1)+
        theme_phil()+
        theme(legend.title = element_text())

elo_ratings_returned_v2$elo_game_results %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        mutate(Model = 'Elo Mean Reversion') %>%
        group_by(HOME_WIN) %>%
        count(HOME_PRED) %>%
        mutate(prop = n / sum(n)) %>%
        ungroup() %>%
        mutate_if(is.numeric, round, 2)

```

I'll add a 25 point bump to the Elo score for the home team, as this roughly maps to about a 3% increase in the probability of winning. I won't add any bonus for games played at neutral sites. I'll now re run making this home team adjustment.

```{r amend functions to include home team adjustment}

update_team_rating_adjusted <- function(team_rating,
                               winner_elo_diff,
                               winner_mov,
                               observed_score,
                               expected_score,
                               k_factor = 10) {
        
        if (observed_score == 1 | observed_score ==0) {
                mov_multi = log(winner_mov+1) * (2.2 / (((winner_elo_diff)*0.001) + 2.2))
        } else {
                mov_multi = 2.2*log(2)
        }
        
        # multiplier for margin of victory

         # now compute updated rating taking into account initial rating and mov
         updated_rating = 
                 team_rating + 
                 (mov_multi *
                          k_factor * 
                          (observed_score - expected_score))
         
         return(updated_rating)
         
}


calc_elo_ratings_with_reversion_home_adjust = function(input_game_matchups,
                            input_team_games,
                            input_initial_team_elo_ratings,
                            k,
                            v,
                            reversion = 1/4,
                            home_adjust = 40) {
        
        # get game ids 
        game_ids = input_game_matchups %>%
                arrange(SEASON, WEEK, GAME_ID) %>%
                select(GAME_ID) %>%
                unique() %>%
                pull(GAME_ID)
        
        # define
        team_elo_ratings = input_initial_team_elo_ratings
        
        # now loop over games and get results
        elo_game_results = foreach (i = 1:length(game_ids), 
                                    .combine = bind_rows) %do% {
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == away_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                
                ### add adjustment for home team if not at a neutral site
                # is the game at a non neutral site?
                neutral_site = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(NEUTRAL_SITE)
                
                if (neutral_site == F) {home_team_adjust = home_adjust} else {home_team_adjust = 0}
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                home_expected_score = get_expected_score(home_team_pre_elo+home_team_adjust,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo+home_team_adjust, 
                                                         V = v)
                
                ## now look at the outcome
                # get the outcome
                home_team_outcome = input_game_matchups %>% 
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(OUTCOME)
                
                # get the margin of victory for the winner
                winner_margin = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        mutate(WIN_MARGIN = abs(HOME_POINTS-AWAY_POINTS)) %>%
                        pull(WIN_MARGIN)
                
                # get the winner elo margin
                if (home_team_outcome == 1) {winner_elo_diff = (home_team_pre_elo + home_team_adjust) - away_team_pre_elo}
                else if (home_team_outcome == 0) {winner_elo_diff = away_team_pre_elo - (home_team_pre_elo + home_team_adjust)}
                else if (home_team_outcome == 0.5) {winner_elo_diff = 0}
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating_adjusted(team_rating = home_team_pre_elo,
                                                                 winner_elo_diff = winner_elo_diff,
                                                                 winner_mov = winner_margin,
                                                                 observed_score = home_team_outcome,
                                                                 expected_score = home_expected_score,
                                                                 k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating_adjusted(team_rating = away_team_pre_elo,
                                                        winner_elo_diff = winner_elo_diff,
                                                        winner_mov = winner_margin,
                                                        observed_score = 1-home_team_outcome,
                                                        expected_score = away_expected_score,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON),
                               WEEK =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                # revert new pre elo meetings to mean if new season
                new_pre_elo_ratings = new_pre_elo_ratings %>%
                        mutate(NEW_SEASON = case_when(SEASON > games_data %>% 
                                                              filter(GAME_ID == game_ids[i]) %>%
                                                              pull(SEASON) ~ T,
                                                      TRUE ~ F)) %>%
                        mutate(TEAM_ELO = case_when(
                                (NEW_SEASON == T & is.na(CONFERENCE)) ~ (reversion)*1200 + (1-reversion)*TEAM_ELO,
                                (NEW_SEASON == T & !is.na(CONFERENCE)) ~ (reversion)*1500 + (1-reversion)*TEAM_ELO,
                               TRUE ~ TEAM_ELO))
                
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                         SEASON =  input_game_matchups %>%
                                              filter(GAME_ID == game_ids[i]) %>%
                                              pull(SEASON),
                        WEEK =  input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_POINTS = input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(HOME_POINTS),
                        AWAY_POINTS = input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(AWAY_POINTS),
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome,
                        HOME_PRE_ELO_ADJUST = home_adjust,
                        NEUTRAL_SITE = neutral_site) %>%
                        mutate(K = k,
                               V = v)
                
                game_result

                                    }
        
        
        # return 
        out = list(
                "elo_game_results" =  elo_game_results,
                "elo_team_ratings" = team_elo_ratings %>%
                        mutate(K = k,
                               V = v))
        
        # return
        return(out)
        
}

```

```{r run with home team adjustment}

elo_ratings_returned = calc_elo_ratings_with_reversion_home_adjust(input_game_matchups = games_data,
                                        input_team_games = team_games,
                                        input_initial_team_elo_ratings = initial_team_elo_ratings,
                                        k=25,
                                        v = 400,
                                        reversion = 1/4,
                                        home_adjust = 25)

```


```{r grab the results from v3}

team_elo_ratings = elo_ratings_returned$elo_team_ratings
elo_game_results = elo_ratings_returned$elo_game_results

```

Still using the SEC as my sniff test.

```{r sec v3}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'SEC') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

And now compare to the previous versions.

```{r compare to previous v1 and v2}

elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        mn_log_loss(truth = HOME_WIN,
                    estimate = HOME_PROB,
                    event_level = 'second') %>%
        mutate(Model = 'Elo Mean Reversion and Home Advantage') %>%
        bind_rows(
                elo_ratings_returned_v1$elo_game_results %>%
                        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
                        group_by(SEASON) %>%
                        mutate(games = n_distinct(GAME_ID)) %>%
                        group_by(SEASON, games) %>%
                        mn_log_loss(truth = HOME_WIN,
                                    estimate = HOME_PROB,
                                    event_level = 'second') %>%
                        mutate(Model = 'Elo')) %>%
        bind_rows(
            elo_ratings_returned_v2$elo_game_results %>%
                        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
                        group_by(SEASON) %>%
                        mutate(games = n_distinct(GAME_ID)) %>%
                        group_by(SEASON, games) %>%
                        mn_log_loss(truth = HOME_WIN,
                                    estimate = HOME_PROB,
                                    event_level = 'second') %>%
                        mutate(Model = 'Elo Mean Reversion')) %>%
        ggplot(., aes(x=SEASON,
                      color = Model,
                      y=.estimate,
                      size = games))+
        geom_point()+
        geom_line(lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.2)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("log-loss")+
        scale_color_manual(values = c("deepskyblue1",
                                      "navy",
                                      "blue"))+
        ggtitle("Average Log-Loss by Season")+
        coord_cartesian(ylim = c(0, 1))

```

I'll look at the overall classification results for each as well.

```{r look at results}

elo_ratings_returned$elo_game_results %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        yardstick::conf_mat(HOME_WIN,
                            HOME_PRED,
                            dnn = c("Home_Pred",
                                    "Home_Win"))

# bind together
bind_rows(
        elo_ratings_returned$elo_game_results %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        mutate(Model = 'Elo Mean Reversion and Home Advantage'),
        elo_ratings_returned_v1$elo_game_results %>%
                select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
                mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
                mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
                mutate(Model = 'Elo'),
        elo_ratings_returned_v2$elo_game_results%>%
                select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
                mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
                mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
                mutate(Model = 'Elo Mean Reversion')) %>%
        group_by(Model, K, V) %>%
        class_metrics(truth = HOME_WIN,
                      estimate = HOME_PRED) %>%
        mutate_if(is.numeric, round, 3) %>%
        flextable() %>%
        autofit()

```

```{r call this v3}

elo_ratings_returned_v3 = elo_ratings_returned

rm(elo_ratings_returned,
   team_elo_ratings,
   elo_game_results)

```


## Simulating Seasons: 1990-1995

Okay, so at this point we have everything we need to try out simulating entire seasons. In order to simulate a season, we just need to know where the team's Elo rating starts at.

To simulate a season, I simulate each game based on the pre game Elo scores for each team. Say that Team A has a 67% chance of winning based on the two teams Elo scores. In that case, I can simulate the game by pulling from a Bernoulli distribution where p =.67. Based on that result, I then compute the outcome and update the ratings. I repeat this process N times for every game, meaning that the Elo ratings are themselves updated on the basis of each simulation.

The snag with this approach is that I'm currently using a margin of victory multiplier to update ratings after each game. This would require not only simulating the winner, but also simulating the point margin. In simulating a season, I could simply ignore the margin of victory multiplier, or always set it equal to some specific margin of victory. Or, I could simulate the point differential directly and then use that to determine the outcome. This is where the point differentials I computed earlier come in.

```{r look at the point differential model, include=F}

library(broom.mixed)
library(tidybayes)

point_diff_v3 = elo_ratings_returned_v3$elo_game_results %>%
        mutate(HOME_PRE_ELO = case_when(NEUTRAL_SITE == F ~ HOME_PRE_ELO + HOME_PRE_ELO_ADJUST,
                                        TRUE ~ HOME_PRE_ELO)) %>%
        mutate(HOME_PRE_ELO_DIFF = HOME_PRE_ELO - AWAY_PRE_ELO) %>%
        mutate(HOME_POINT_DIFF = HOME_POINTS - AWAY_POINTS) %>%
        nest() %>%
        mutate(lm = map(data, ~ stan_glm(HOME_POINT_DIFF ~ HOME_PRE_ELO_DIFF,
                                   data = .x))) %>%
        mutate(tidied = map(lm, tidy, se="robust", conf.int=T)) %>%
        mutate(preds = map(lm, predict)) %>%
        mutate(glanced = map(lm, glance))

```

Looking at the results of a simple linear regression of the home team's point differential (home points - away points) on the home team's pre game elo differential, we see that a one point increase in the home team's Elo increases its expected point differential by 0.06. This means a 100 point difference in ELo is equivalent to a 6 point differential. 

```{r look at point differential model from these seasons}

# look at the model
point_diff_v3 %>%
        select(tidied) %>%
        unnest() %>%
        mutate_if(is.numeric, round, 2)

# look at the results
point_diff_v3 %>%
        select(glanced) %>%
        unnest()
        
# look at the model
point_diff_v3 %>%
        select(data, preds) %>%
        unnest() %>%
        mutate(preds = round(preds, 0)) %>%
        ggplot(., aes(x=preds,
                      y=HOME_POINT_DIFF))+
        geom_point()+
        theme_phil()+
        xlab("Predicted Home Point Differential")+
        ylab("Actual Home Point Differential")+
        theme_phil()+
        geom_hline(yintercept=0,
                   linetype = 'dashed')+
        geom_vline(xintercept =0,
                   linetype = 'dashed')+
        geom_smooth(method = 'lm',
                    formula = 'y ~ x',
                    color = 'blue')+
        stat_cor(
                aes(label = paste(..rr.label.., ..p.label.., sep = "~`,`~")), 
                p.accuracy = 0.01,
                color = 'blue')

```


This simple bivariate model explains about 36% of the variation in the home point differential, with a residual standard deviation of 16, so we shouldn't expect it to be dead on the money in predicting the spread. However, we can simulate from this model to get the simulated margin of victory for games, which we can then use in simulating games alogn with their margin of victory.

```{r get initial ratings for next run of seasons}

set.seed(2)
point_diff_v3 %>% 
        mutate(sims = map(lm, ~ posterior_predict(.x, draws=1) %>% 
                                  tidy_draws %>% 
                                  gather("row", ".pred", -.chain, -.iteration, -.draw))) %>% 
        select(data, sims) %>% 
        unnest() %>%
        mutate(.pred = round(.pred, 0)) %>%
        mutate(HOME_POINT_DIFF_char = case_when(HOME_POINT_DIFF > 0 ~ paste("+", HOME_POINT_DIFF, sep=""),
                                    HOME_POINT_DIFF == 0 ~ paste("Tie"),
                                    HOME_POINT_DIFF < 0 ~ paste(HOME_POINT_DIFF, sep=""))) %>%
        mutate(sim_char = case_when(.pred > 0 ~ paste("+", .pred, sep=""),
                                    .pred == 0 ~ paste("Tie"),
                                    .pred < 0 ~ paste(.pred, sep="")),
               GAME = paste(HOME_TEAM, " ", AWAY_TEAM, "\n",
                            "Actual: ", HOME_TEAM, " ", HOME_POINT_DIFF_char, "\n",
                            "Sim: ", HOME_TEAM, " ", sim_char, sep="")) %>%
        mutate(CORRECT = case_when(.pred >0 & HOME_POINT_DIFF >0 ~ 'yes',
                                   .pred <0 & HOME_POINT_DIFF <0 ~ 'yes',
                                   TRUE ~ 'no')) %>%
        sample_n(1000) %>%
        ggplot(., aes(x=HOME_POINT_DIFF,
                      color = CORRECT,
                      label = GAME,
                      y=.pred))+geom_point()+
        geom_text(check_overlap=T, 
                  vjust=-0.5, size=2)+
        theme_phil()+
       scale_color_manual(values = c("red", "blue"))+
        geom_vline(xintercept =0,
                   linetype = 'dotted')+
        geom_hline(yintercept = 0,
                   linetype = 'dotted')+
        xlab("Simulated Point Diff")+
        ylab("Actual Point Diff")


```

```{r get model for simulating the draw}

# grab the model
points_model = point_diff_v3 %>%
        pluck("lm", 1)

```

I'm going to simulate the outcome by simulating the draw from the points model. This will simulate the outcome and the margin.

```{r reset simulate data for 1991}

# get universe of games
games_data = games_data_raw %>%
        filter(SEASON >1990 & SEASON <=1991) %>%
        select(GAME_ID, SEASON, WEEK, VENUE, HOME_TEAM, AWAY_TEAM, HOME_CONFERENCE, AWAY_CONFERENCE, HOME_POINTS, AWAY_POINTS, NEUTRAL_SITE) %>%
        mutate(OUTCOME = case_when(HOME_POINTS > AWAY_POINTS ~ 1,
                                   HOME_POINTS == AWAY_POINTS ~ 0.5,
                                   HOME_POINTS < AWAY_POINTS ~ 0)) %>%
        arrange(SEASON, WEEK, GAME_ID)

# now get this at the team level
team_games = games_data %>%
        select(SEASON, GAME_ID, WEEK, HOME_TEAM, HOME_CONFERENCE) %>%
        rename(TEAM = HOME_TEAM,
               CONFERENCE = HOME_CONFERENCE) %>%
        bind_rows(., games_data %>%
                          select(SEASON, GAME_ID, WEEK, AWAY_TEAM, AWAY_CONFERENCE) %>%
                          rename(TEAM = AWAY_TEAM,
                                 CONFERENCE = AWAY_CONFERENCE)) %>%
        arrange(SEASON, WEEK, GAME_ID)

# set as initial ratings
initial_team_elo_ratings = team_games %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        group_by(TEAM) %>%
        filter(SEASON == min(SEASON)) %>%
        filter(WEEK == min(WEEK)) %>%
        ungroup() %>%
        mutate(TYPE = "Pre_Elo") %>%
        left_join(.,
                  elo_ratings_returned_v3$elo_team_ratings %>%
                        filter(TYPE == 'Post_Elo') %>%
                        select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE, TYPE, TEAM_ELO) %>%
                        group_by(TEAM) %>%
                        filter(SEASON == max(SEASON)) %>%
                        filter(WEEK == max(WEEK)) %>%
                        spread(TYPE, TEAM_ELO) %>%
                        select(TEAM, CONFERENCE, Post_Elo) %>%
                        mutate(TEAM_ELO = case_when(!is.na(CONFERENCE) ~ (1/4)*1500 + (3/4*Post_Elo),
                                                   is.na(CONFERENCE) ~ (1/4)*1200 + (3/4*Post_Elo))) %>%
                        mutate(TYPE = 'Pre_Elo') %>%
                        arrange(desc(TEAM_ELO)) %>%
                        ungroup() %>%
                        select(TEAM, TYPE, TEAM_ELO),
                  by = c("TEAM","TYPE")
                  ) %>%
        mutate(TEAM_ELO = case_when(is.na(TEAM_ELO) & is.na(CONFERENCE) ~ 1200,
                                    is.na(TEAM_ELO) & !is.na(CONFERENCE) ~ 1500,
                                    TRUE ~ TEAM_ELO))
        
```


```{r make function to sim season with score}

sim_season_with_reversion_home_adjust = function(input_game_matchups,
                            input_team_games,
                            input_initial_team_elo_ratings,
                            input_points_model,
                            k,
                            v,
                            reversion = 1/4,
                            home_adjust = 25) {
        
        # get game ids 
        game_ids = input_game_matchups %>%
                arrange(SEASON, WEEK, GAME_ID) %>%
                select(GAME_ID) %>%
                unique() %>%
                pull(GAME_ID)
        
        # define
        team_elo_ratings = input_initial_team_elo_ratings
        
        # now loop over games and get results
        elo_game_results = foreach (i = 1:length(game_ids), 
                                    .combine = bind_rows) %do% {
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == away_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                
                ### add adjustment for home team if not at a neutral site
                # is the game at a non neutral site?
                neutral_site = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(NEUTRAL_SITE)
                
                if (neutral_site == F) {home_team_adjust = home_adjust} else {home_team_adjust = 0}
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                home_expected_score = get_expected_score(home_team_pre_elo+home_team_adjust,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo+home_team_adjust, 
                                                         V = v)
                
                ## simulate the outcome
                posterior_mov = posterior_predict(input_points_model,
                                                  newdata = 
                                                          data.frame(HOME_PRE_ELO_DIFF = 
                                                                             home_team_pre_elo + home_team_adjust - away_team_pre_elo),
                                                  draws=1) %>%
                        as.vector()
                
                # grab pieces we need from the outcome
                sim_outcome = tibble(sim_mov = round(posterior_mov, 0)) %>%
                        mutate(home_team_outcome = case_when(sim_mov > 0 ~ 1,
                                             sim_mov < 0 ~ 0,
                                             sim_mov == 0 ~ 0.5)) %>%
                        mutate(winner_mov = abs(sim_mov))

                ## now look at the outcome
                # get the outcome
                home_team_outcome = sim_outcome$home_team_outcome
                
                # get the margin of victory for the winner
                winner_margin = sim_outcome$winner_mov
                
                # get the winner elo margin
                if (home_team_outcome == 1) {winner_elo_diff = (home_team_pre_elo + home_team_adjust) - away_team_pre_elo}
                else if (home_team_outcome == 0) {winner_elo_diff = away_team_pre_elo - (home_team_pre_elo + home_team_adjust)}
                else if (home_team_outcome == 0.5) {winner_elo_diff = 0}
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating_adjusted(team_rating = home_team_pre_elo,
                                                                 winner_elo_diff = winner_elo_diff,
                                                                 winner_mov = winner_margin,
                                                                 observed_score = home_team_outcome,
                                                                 expected_score = home_expected_score,
                                                                 k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating_adjusted(team_rating = away_team_pre_elo,
                                                        winner_elo_diff = winner_elo_diff,
                                                        winner_mov = winner_margin,
                                                        observed_score = 1-home_team_outcome,
                                                        expected_score = away_expected_score,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON),
                               WEEK =  input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                # revert new pre elo meetings to mean if new season
                new_pre_elo_ratings = new_pre_elo_ratings %>%
                        mutate(NEW_SEASON = case_when(SEASON > games_data %>% 
                                                              filter(GAME_ID == game_ids[i]) %>%
                                                              pull(SEASON) ~ T,
                                                      TRUE ~ F)) %>%
                        mutate(TEAM_ELO = case_when(
                                (NEW_SEASON == T & is.na(CONFERENCE)) ~ (reversion)*1200 + (1-reversion)*TEAM_ELO,
                                (NEW_SEASON == T & !is.na(CONFERENCE)) ~ (reversion)*1500 + (1-reversion)*TEAM_ELO,
                               TRUE ~ TEAM_ELO))
                
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                         SEASON =  input_game_matchups %>%
                                              filter(GAME_ID == game_ids[i]) %>%
                                              pull(SEASON),
                        WEEK =  input_game_matchups %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome,
                        HOME_POINT_DIFF = sim_outcome$sim_mov,
                        HOME_PRE_ELO_ADJUST = home_adjust,
                        NEUTRAL_SITE = neutral_site) %>%
                        mutate(K = k,
                               V = v)
                
                game_result

                                    }
        
        
        # return 
        out = list(
                "elo_game_results" =  elo_game_results,
                "elo_team_ratings" = team_elo_ratings %>%
                        mutate(K = k,
                               V = v))
        
        # return
        return(out)
        
}

```


```{r remake sim season function to be faster}

sim_season_with_reversion_home_adjust = function(input_game_matchups,
                            input_team_games,
                            input_initial_team_elo_ratings,
                            input_points_model,
                            k,
                            v,
                            reversion = 1/4,
                            home_adjust = 25) {
        
        # get game ids 
        game_ids = input_game_matchups %>%
                arrange(SEASON, WEEK, GAME_ID) %>%
                select(GAME_ID) %>%
                pull(GAME_ID)
        
        # define
        team_elo_ratings = input_initial_team_elo_ratings
        
        # now loop over games and get results
        elo_game_results = foreach (i = 1:length(game_ids)) %do% {
                
                game_season = input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON)
                
                game_week = input_game_matchups %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK)
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = input_game_matchups %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == away_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                
                ### add adjustment for home team if not at a neutral site
                # is the game at a non neutral site?
                neutral_site = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(NEUTRAL_SITE)
                
                if (neutral_site == F) {home_team_adjust = home_adjust} else {home_team_adjust = 0}
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                home_expected_score = get_expected_score(home_team_pre_elo+home_team_adjust,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo+home_team_adjust, 
                                                         V = v)
                
                ## simulate the outcome
                posterior_mov = posterior_predict(input_points_model,
                                                  newdata = 
                                                          data.frame(HOME_PRE_ELO_DIFF = 
                                                                             home_team_pre_elo + home_team_adjust - away_team_pre_elo),
                                                  draws=1) %>%
                        as.vector()
                
                # grab pieces we need from the outcome
                sim_outcome = tibble(sim_mov = round(posterior_mov, 0)) %>%
                        mutate(home_team_outcome = case_when(sim_mov > 0 ~ 1,
                                             sim_mov < 0 ~ 0,
                                             sim_mov == 0 ~ 0.5)) %>%
                        mutate(winner_mov = abs(sim_mov))

                ## now look at the outcome
                # get the outcome
                home_team_outcome = sim_outcome$home_team_outcome
                
                # get the margin of victory for the winner
                winner_margin = sim_outcome$winner_mov
                
                # get the winner elo margin
                if (home_team_outcome == 1) {winner_elo_diff = (home_team_pre_elo + home_team_adjust) - away_team_pre_elo}
                else if (home_team_outcome == 0) {winner_elo_diff = away_team_pre_elo - (home_team_pre_elo + home_team_adjust)}
                else if (home_team_outcome == 0.5) {winner_elo_diff = 0}
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating_adjusted(team_rating = home_team_pre_elo,
                                                                 winner_elo_diff = winner_elo_diff,
                                                                 winner_mov = winner_margin,
                                                                 observed_score = home_team_outcome,
                                                                 expected_score = home_expected_score,
                                                                 k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating_adjusted(team_rating = away_team_pre_elo,
                                                        winner_elo_diff = winner_elo_diff,
                                                        winner_mov = winner_margin,
                                                        observed_score = 1-home_team_outcome,
                                                        expected_score = away_expected_score,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  game_season,
                               WEEK =  game_week,
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  input_team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                # revert new pre elo meetings to mean if new season
                new_pre_elo_ratings = new_pre_elo_ratings %>%
                        mutate(NEW_SEASON = case_when(SEASON > games_data %>% 
                                                              filter(GAME_ID == game_ids[i]) %>%
                                                              pull(SEASON) ~ T,
                                                      TRUE ~ F)) %>%
                        mutate(TEAM_ELO = case_when(
                                (NEW_SEASON == T & is.na(CONFERENCE)) ~ (reversion)*1200 + (1-reversion)*TEAM_ELO,
                                (NEW_SEASON == T & !is.na(CONFERENCE)) ~ (reversion)*1500 + (1-reversion)*TEAM_ELO,
                               TRUE ~ TEAM_ELO))
                
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                        SEASON = game_season,
                        WEEK = game_week,
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome,
                        HOME_POINT_DIFF = sim_outcome$sim_mov,
                        HOME_PRE_ELO_ADJUST = home_adjust)
                
                game_result

                                    }
        
        # return
        return(elo_game_results %>%
                       rbindlist())
        
}

```



```{r register parallel backend}

library(parallel)
library(doParallel)

doParallel::registerDoParallel(detectCores()-6)
registerDoSEQ()

```

```{r run simulation for seasons}

sims_elo_returned = foreach(s = 1:100) %do% {

       out =  sim_season_with_reversion_home_adjust(input_game_matchups = games_data,
                                                         input_team_games = team_games,
                                                         input_initial_team_elo_ratings = initial_team_elo_ratings,
                                                         input_points_model = points_model,
                                                         k = 25,
                                                         v = 400,
                                                         reversion = 1/4,
                                                         home_adjust = 25)
     
       out
       
}

```

```{r look at the results for one season}

sims_elo_returned %>%
        rbindlist(., idcol=T) %>%
        mutate(TEAM = HOME_TEAM,
               OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'win',
                                   HOME_OUTCOME == 0 ~ 'loss',
                                   HOME_OUTCOME == 0.5 ~ 'tie'),
               POINT_DIFF = HOME_POINT_DIFF) %>%
        select(SEASON, GAME_ID, TEAM, OUTCOME, POINT_DIFF) %>%
        mutate(HOST = 'HOME') %>%
        bind_rows(.,
                  sims_elo_returned %>%
                          rbindlist(., idcol=T) %>%
                          mutate(TEAM = AWAY_TEAM,
                                 OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'loss',
                                   HOME_OUTCOME == 0 ~ 'win',
                                   HOME_OUTCOME == 0.5 ~ 'tie'),
                                 POINT_DIFF = -HOME_POINT_DIFF) %>%
                          select(SEASON, GAME_ID, TEAM, OUTCOME, POINT_DIFF) %>%
                          mutate(HOST='AWAY')) %>%
        group_by(SEASON, TEAM) %>%
        count(OUTCOME) %>%
        spread(OUTCOME, n) %>%
        select(SEASON, TEAM, win, loss, tie) %>%
        arrange(desc(win)) %>% 
        ungroup() %>%
        mutate_if(is.numeric, replace_na, 0)

```

Predicted wins vs actual

```{r compare predicted vs actual wins for simulation}

games_data %>%
        mutate_if(is.numeric, round, 2) %>%
        mutate(TEAM = HOME_TEAM,
               OUTCOME = case_when(OUTCOME == 1 ~ 'win',
                                   OUTCOME == 0 ~ 'loss',
                                   OUTCOME == 0.5 ~ 'tie'),
               POINT_DIFF = HOME_POINTS - AWAY_POINTS,
               OPPONENT = AWAY_TEAM) %>%
        select(SEASON, GAME_ID, TEAM, OPPONENT, OUTCOME, POINT_DIFF) %>%
        mutate(HOST = 'HOME') %>%
        bind_rows(.,
                  games_data %>%
                          mutate(TEAM = AWAY_TEAM,
                                 OUTCOME = case_when(OUTCOME == 1 ~ 'loss',
                                                     OUTCOME == 0 ~ 'win',
                                                     OUTCOME == 0.5 ~ 'tie'),
                                 POINT_DIFF = AWAY_POINTS - HOME_POINTS,
                                 OPPONENT = HOME_TEAM) %>%
                          select(SEASON, GAME_ID, TEAM, OUTCOME, OPPONENT, POINT_DIFF) %>%
                          mutate(HOST='AWAY')) %>%
        arrange(GAME_ID) %>%
        group_by(SEASON, TEAM) %>%
        count(OUTCOME) %>%
        spread(OUTCOME, n) %>%
        select(SEASON, TEAM, win, loss, tie) %>%
        arrange(desc(win)) %>% 
        ungroup() %>%
        mutate_if(is.numeric, replace_na, 0) %>%
        rename(actual_wins = win) %>%
        select(SEASON, TEAM, actual_wins) %>%
        left_join(.,
                sims_elo_returned %>%
                        rbindlist(., idcol=T) %>%
                        mutate(TEAM = HOME_TEAM,
                               OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'win',
                                                   HOME_OUTCOME == 0 ~ 'loss',
                                                   HOME_OUTCOME == 0.5 ~ 'tie'),
                               POINT_DIFF = HOME_POINT_DIFF) %>%
                        select(SEASON, GAME_ID, TEAM, OUTCOME, POINT_DIFF) %>%
                        mutate(HOST = 'HOME') %>%
                        bind_rows(.,
                                  sims_elo_returned %>%
                                          rbindlist(., idcol=T) %>%
                                          mutate(TEAM = AWAY_TEAM,
                                                 OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'loss',
                                                   HOME_OUTCOME == 0 ~ 'win',
                                                   HOME_OUTCOME == 0.5 ~ 'tie'),
                                                 POINT_DIFF = -HOME_POINT_DIFF) %>%
                                          select(SEASON, GAME_ID, TEAM, OUTCOME, POINT_DIFF) %>%
                                          mutate(HOST='AWAY')) %>%
                        group_by(SEASON, TEAM) %>%
                        count(OUTCOME) %>%
                        spread(OUTCOME, n) %>%
                        select(SEASON, TEAM, win, loss, tie) %>%
                        arrange(desc(win)) %>% 
                        ungroup() %>%
                        mutate_if(is.numeric, replace_na, 0) %>%
                        rename(pred_wins = win) %>%
                        select(SEASON, TEAM, pred_wins),
                by = c("SEASON", "TEAM")) %>%
        left_join(.,
                  team_games %>%
                          select(SEASON, CONFERENCE, TEAM) %>%
                          unique(),
                  by = c("SEASON", "TEAM")) %>%
        filter(!is.na(CONFERENCE)) %>%
        ggplot(., aes(x=pred_wins,
                      label = TEAM,
                      y = actual_wins))+
        geom_point(position=ggforce::position_jitternormal())+
        geom_text_repel(size=2.5)+
        facet_wrap(CONFERENCE ~.)+
        theme_bw()+
        geom_abline(slope=1,
                    intercept=0,
                    linetype = 'dashed')
        
```



```{r sims elo returned}

sims_elo_returned %>%
        rbindlist(., idcol=T) %>%
        mutate_if(is.numeric, round, 2) %>%
        mutate(TEAM = HOME_TEAM,
               TEAM_PRE_ELO = HOME_PRE_ELO,
               TEAM_POST_ELO = HOME_POST_ELO,
               OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'win',
                                   HOME_OUTCOME == 0 ~ 'loss',
                                   HOME_OUTCOME == 0.5 ~ 'tie'),
               POINT_DIFF = HOME_POINT_DIFF,
               OPPONENT = AWAY_TEAM) %>%
        select(GAME_ID, TEAM, TEAM_PRE_ELO, TEAM_POST_ELO, OPPONENT, OUTCOME, POINT_DIFF) %>%
        mutate(HOST = 'HOME') %>%
        bind_rows(.,
                  sims_elo_returned %>%
                          rbindlist(., idcol=T) %>%
                          mutate(TEAM = AWAY_TEAM,
                                 TEAM_PRE_ELO = AWAY_PRE_ELO,
                                 TEAM_POST_ELO = AWAY_POST_ELO,
                                 OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'loss',
                                   HOME_OUTCOME == 0 ~ 'win',
                                   HOME_OUTCOME == 0.5 ~ 'tie'),
                                 POINT_DIFF = -HOME_POINT_DIFF,
                                 OPPONENT = HOME_TEAM) %>%
                          select(GAME_ID, TEAM, TEAM_PRE_ELO, TEAM_POST_ELO, OUTCOME, OPPONENT, POINT_DIFF) %>%
                          mutate(HOST='AWAY')) %>%
        arrange(GAME_ID) %>%
      #  arrange(GAME_ID) %>%
                filter(TEAM == 'Texas A&M')

```

```{r sim multiple times}

sims_elo_returned = foreach(s = 1:100) %do% {

       out =  sim_season_with_reversion_home_adjust(input_game_matchups = games_data,
                                                         input_team_games = team_games,
                                                         input_initial_team_elo_ratings = initial_team_elo_ratings,
                                                         input_points_model = points_model,
                                                         k = 25,
                                                         v = 400,
                                                         reversion = 1/4,
                                                         home_adjust = 25)
     
       out
       
}

```

```{r look at simulations}

sims_elo_returned %>%
        rbindlist(., idcol=T) %>%
        mutate_if(is.numeric, round, 2) %>%
        mutate(TEAM = HOME_TEAM,
               TEAM_PRE_ELO = HOME_PRE_ELO,
               TEAM_POST_ELO = HOME_POST_ELO,
               OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'win',
                                   HOME_OUTCOME == 0 ~ 'loss',
                                   HOME_OUTCOME == 0.5 ~ 'tie'),
               POINT_DIFF = HOME_POINT_DIFF,
               OPPONENT = AWAY_TEAM) %>%
        select(SEASON, GAME_ID, TEAM, TEAM_PRE_ELO, TEAM_POST_ELO, OPPONENT, OUTCOME, POINT_DIFF, .id) %>%
        mutate(HOST = 'HOME') %>%
        bind_rows(.,
                  sims_elo_returned %>%
                          rbindlist(., idcol=T) %>%
                          mutate(TEAM = AWAY_TEAM,
                                 TEAM_PRE_ELO = AWAY_PRE_ELO,
                                 TEAM_POST_ELO = AWAY_POST_ELO,
                                 OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'loss',
                                   HOME_OUTCOME == 0 ~ 'win',
                                   HOME_OUTCOME == 0.5 ~ 'tie'),
                                 POINT_DIFF = -HOME_POINT_DIFF,
                                 OPPONENT = HOME_TEAM) %>%
                          select(SEASON, GAME_ID, TEAM, TEAM_PRE_ELO, TEAM_POST_ELO, OUTCOME, OPPONENT, POINT_DIFF, .id) %>%
                          mutate(HOST='AWAY')) %>%
        left_join(.,
                  team_games %>%
                          select(SEASON, CONFERENCE, TEAM) %>%
                          unique(),
                  by = c("SEASON", "TEAM")) %>%
        filter(CONFERENCE == 'Big Ten') %>%
        group_by(SEASON, TEAM, .id) %>%
        count(OUTCOME) %>%
        filter(OUTCOME == 'win') %>%
        ggplot(., aes(x=n))+
        geom_histogram(bins=30)+
        facet_wrap(SEASON + TEAM~.)+
        theme_bw()

```

```{r sim seasons}

mode_func <- function(codes){
  which.max(tabulate(codes))
}

sims_elo_returned %>%
        rbindlist(., idcol=T) %>%
     mutate_if(is.numeric, round, 2) %>%
     mutate(TEAM = HOME_TEAM,
           TEAM_PRE_ELO = HOME_PRE_ELO,
           TEAM_POST_ELO = HOME_POST_ELO,
            OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'win',
                                HOME_OUTCOME == 0 ~ 'loss',
                                HOME_OUTCOME == 0.5 ~ 'tie'),
            POINT_DIFF = HOME_POINT_DIFF,
            OPPONENT = AWAY_TEAM) %>%
     select(SEASON, GAME_ID, TEAM, TEAM_PRE_ELO, TEAM_POST_ELO, OPPONENT, OUTCOME, POINT_DIFF, .id) %>%
     mutate(HOST = 'HOME') %>%
     bind_rows(.,
               sims_elo_returned %>%
                   rbindlist(., idcol=T) %>%
                   mutate(TEAM = AWAY_TEAM,
                          TEAM_PRE_ELO = AWAY_PRE_ELO,
                          TEAM_POST_ELO = AWAY_POST_ELO,
                          OUTCOME = case_when(HOME_OUTCOME == 1 ~ 'loss',
                                              HOME_OUTCOME == 0 ~ 'win',
                                              HOME_OUTCOME == 0.5 ~ 'tie'),
                          POINT_DIFF = -HOME_POINT_DIFF,
                          OPPONENT = HOME_TEAM) %>%
                   select(SEASON, GAME_ID, TEAM, TEAM_PRE_ELO, TEAM_POST_ELO, OUTCOME, OPPONENT, POINT_DIFF, .id) %>%
                   mutate(HOST='AWAY')) %>%
     left_join(.,
               team_games %>%
                   select(SEASON, CONFERENCE, TEAM) %>%
                   unique(),
               by = c("SEASON", "TEAM")) %>%
     group_by(SEASON, TEAM, .id) %>%
     count(OUTCOME) %>%
        filter(OUTCOME == 'win') %>% 
        group_by(SEASON, TEAM) %>%
        summarize(mean_wins = mean(n),
                  mode_wins = mode_func(n),
                  .groups = 'drop') %>% 
        arrange(desc(mode_wins)) %>%
        mutate_if(is.numeric, round, 2)

```

