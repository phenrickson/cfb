---
title: "CFB Elo Ratings"
author: "Phil Henrickson"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE #adds a Table of Contents
    theme: cerulean
    number_sections: TRUE #number your headings/sections
    toc_float: TRUE #let your ToC follow you as you scroll
    keep_md: no
    fig.caption: yes
    css: "styles.css"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = F,
                      error = F,
                      warning=F,
                      dev="png",
                      fig.width = 10,
                      fig.height = 6)

options(knitr.duplicate.label = "allow")

options(scipen=999)

```

```{r connect to snowflake}

library(DBI)
library(odbc)
library(RODBC)
library(keyring)

# connect to snowflake
myconn <- DBI::dbConnect(odbc::odbc(),
                         "SnowflakeDSII",
                         Database = "CFB_DEMO",
                         warehouse = "DEMO_WH",
                         uid="phil.henrickson",
                         pwd=keyring::key_get("AE_Snowflake"))

```

```{r packages, include=F} 

source(here::here("scripts/load_packages.R"))
library(rstan)
library(rstanarm)
library(rstantools)
library(jsonlite)
library(forcats)
conflict_prefer("lag", "dplyr")

```

```{r load functions}

source(here::here("functions/theme_phil.R"))
rm(a)
```

```{r get games}

# get games
games_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.GAMES')) %>%
        as_tibble() %>%
        mutate(ID = as.numeric(ID)) %>%
        rename(GAME_ID = ID)

# recruiting
recruiting_teams_data_raw = DBI::dbGetQuery(myconn,
                             paste('SELECT * FROM CFB_DEMO.CFD_RAW.RECRUITING_TEAMS')) %>%
        as_tibble()
        
```

# What is this? {-}

This notebook explores creating Elo ratings for college football teams using data from the late 1800s to present.

# The Data

The data we're using is at the game level, in which we have features indicating the season, the week, the location, the teams, and the score. 

```{r game level data for all teams}

set.seed(8)
games_data_raw %>%
        filter(SEASON > 2000 & SEASON < 2017) %>%
        sample_n(5) %>%
        select(GAME_ID, SEASON, WEEK, VENUE, HOME_TEAM, AWAY_TEAM, HOME_POINTS, AWAY_POINTS) %>%
        mutate(HOME_WIN = case_when(HOME_POINTS > AWAY_POINTS ~ 'yes',
                                    TRUE ~ 'no')) %>%
        mutate(GAME_ID = as.character(GAME_ID),
               SEASON = as.character(SEASON)) %>%
        flextable() %>%
        autofit()

```

We also have additional features on team conferences, attendance, start time, betting line, as well as information from an existing Elo Model. We'll set that aside for now, as our goal here is to go through the process of developing our own Elo model. 

We lose some information the further we go back, but we have outcomes of games back to the very first game between Rutgers and Princeton in 1869.

```{r get outcomes since 1869}

games_data_raw %>%
        group_by(SEASON) %>%
        summarize(n_games = n_distinct(GAME_ID)) %>%
        ggplot(., aes(x=SEASON,
                      y=n_games))+
        geom_col()+
        theme_phil()

```

# Elo Ratings

What exactly is an Elo rating? It takes its name from the guy who first came up with the idea, Arpad Elo, who developed it for the purpose of ranking chess players: https://en.wikipedia.org/wiki/Elo_rating_system. I note this because people commonly refer to these as ELO scores - no, it's Elo, it's from his name.

The basic idea is to, for any given matchup between opponents, assign a rating to each opponent that can be used to predict the outcome of the match. The result of the match will then influence their ensuing ratings, with the winner gaining points from the loser. An opponent's rating is always a function of prior results, taking into account their performance in previous matches as well as the ratings of their opponents. 

## The Expected Score

For the full description of how this works, check out the Wikipedia page, but I'll paraphrase it here to the best of my ability. Say we've got an upcoming match between two opponents, $A$ and $B$. In an Elo rating system, the expected result, or score, for Opponent $A$ in a match against Opponent $B$ is: $$E_A = \frac{1}{1+10^{(R_B-R_A)/V}}$$

What does this equation mean?

* $E_A$ is Opponent's A expected score from the match - in the case of matchup between two opponents, this basically just reduces to win probability.

* $R_A$ is Opponent A's pre match rating

* $R_B$ is Opponent B's pre match rating

* 10 is the base value used in the rating system; typically 10 is used in these types of ratings

* V is a scaling factor that sets how much a difference in rating between the two opponents will affect the probability of either side winning. More on this in a second.

How did we get this equation? It's just a logistic curve of the form $f(x) = \frac{1}{1+e^{-x}}$, which is the standard logistic function with a growth rate and curve maximum of 1. Don't worry about this too much, it basically just constrains any input of x to return a number between 0 and 1.

Similarly, the expected score for Opponent B is: $$E_B = \frac{1}{1+10^{(R_A-R_B)/V}}$$

What's the point of this equation? We can input ratings for $A$ and $B$ and get back an expected score for an opponent based on the difference between the two opponent's rating.

```{r write a function for elo, echo=T}

get_expected_score <- function(R_A, R_B, V=400) {
        
        return(1 / (1 + 10^((R_B - R_A) / V)))
        
        }

```

If the two opponents have equal ratings, the difference between their rating is zero, and the the expected score reduces to 0.5. Why? When the difference is zero, anything raised to the 0 is 1, and the scaling factor no longer matters:  $$E_A = \frac{1}{1+10^{0/V}} = \frac{1}{1+1} = \frac{1}{2}$$

So, anytime we have two perfectly equal opponents, the expected score reduces to a coin flip.

Okay, but now suppose that $R_A$ is 100 and $R_B$ is 50 and $V$ is 200. Plugging these numbers into the equation above, we get an expected score for A of `r round(get_expected_score(R_A = 100, R_B = 50, V = 200), 4)`. In this case, $A$ is more likely to win, as they have a higher rating. In this case, the scaling factor $V$ determines how much the difference in rating matters for the expected score:

$$E_A = \frac{1}{1+10^{(50-100)/200}} = \frac{1}{1+10^{-50/200}} = \frac{1}{1+10^{-1/4}} \approx \frac{1}{1+.5623}  \approx  0.64$$
If the scaling factor $V$ was set to 50, the difference in rating between these two teams would be considered much bigger.

$$E_A = \frac{1}{1+10^{(50-100)/50}} = \frac{1}{1+10^{-50/50}} = \frac{1}{1+10^{-1}} \approx \frac{1}{1+.0.1}  \approx  0.909$$
Tangibly, this means the scaling factor indicates the difference at which one opponent's expected score would be ten times greater than their opponent's expected score. I'll plot the expected score for $A$ as a function of the difference between $R_B$ and $R_A$ using different values of $V$ for the scaling factor.

```{r test the func}

a_vals = seq(0, 100, 1)
b_vals = rep(50, length(a_vals))
v_vals = c(5, 10, 25, 50, 100)

foo = foreach(i=1:length(a_vals), .combine=bind_rows) %:% 
        foreach(j = 1:length(v_vals), .combine=bind_rows) %do% {
        
        get_expected_score(a_vals[i],
                           b_vals[i],
                           v_vals[j]) %>%
                        as_tibble() %>%
                        mutate(diff = a_vals[i]-b_vals[i],
                               v = v_vals[j])
        }

# plot
foo %>%
        mutate(v = as.factor(v)) %>%
        ggplot(., aes(x=diff,
              color = v,
              group = v,
             y=value))+
        geom_line(lwd=1.1)+
        theme_bw()+
        xlab("Rating B - Rating A")+
        ylab("Expected Score A")+
        scale_color_viridis_d()

rm(foo)

```
All this is to say that the selection of the scaling factor and the initial Elo values determine the scaling of the ratings, and we can make decisions about these. 

## Updating Elo Ratings

But none of this so far gets to the real heart of why Elo ratings prove to be useful, which is that they are always updating based on new results.  After a match between opponents, the outcome of the match determines each opponent's updated rating.

As we said earlier, before the match, $R_A$ is 100 and $R_B$ is 50 and $V$ is 200. After the match, we recalculate each opponent's score taking into account what happened in the match. How do we do this? The equation looks like this:

$$R'_A = R_A + K*(S_A - E_A)$$
We update $R'_A$ based on the previous rating plus the difference between what they actually scored $S_A$ minus what they were expected to score $E_A$, multiplied by the $K$-factor, which determines the maximum possible adjustment between games.

Let's say that that $A$ lost the match to $B$. Their initial score was 100. If the k-factor is set to 10, the most their score could drop is 10 points. They will drop by slightly less than that, based on their expected score:

$$R'_A = 100 + 10*(0 - 0.64) \approx 93.6$$
$B$, on the other hand, would get a boost to their rating.

$$R'_B = 50 + 10*(1 - 0.36) \approx 56.4$$

In this way, the winner picks up points from the loser, and $K$ determines how many points can be transferred in one match

## Margin of Victory

The original Elo rating updated didn't take into account the margin of victory by the winner, effectively treating close losses and blowouts as the same result. Fortunately, we can make a slight change to the formula for updating ratings in order to account for the margin of victory by the winner. I'm adapting the approach I'll try out here after the methodology described at https://fivethirtyeight.com/methodology/how-our-nfl-predictions-work/

How do we account for the margin of victory in updating the rating? We add a multiplier $M$ based on the margin of victory for the winner in addition to the K factor: 

$$R'_A = R_A + M*K*(S_A - E_A)$$

538 uses a margin of victory multiplier in their ratings that looks like this:

$$ M = MarginMulti = ln(WinnerPointDiff + 1) * Adjustment$$
Ignore the adjustment piece for a second. The idea is to multiply the result of the game by taking the natural log of the winner's point differential + 1 (as ln(0) is undefined). When the point differential is zero, the margin multiplier reduces to 0 and there is no multiplier. When the differential is positive the winner gets more points from their opponent based on how much they won by, with diminishing credit the further out we go in the margin of victory.

```{r plot of margin of victory}

tibble(x = seq(0, 50),
       y = log(x+1)) %>%
        ggplot(., aes(x=x,
                      y=y))+
        geom_line()+
        theme_phil()+
        xlab("x")+
        ylab("log(x+1)")

```

What about that adjustment? 538 discusses adjusting for autocorrelation, which is correlation within a time series between its current and past values. In the case of Elo ratings, if we only include a margin multiplier, we will quickly find that teams that are winning a lot are also winning by high margins. This means we'll end up with a positive feedback loop for winning teams which, lacking any sort of adjustment, can lead to inflated ratings for good teams.

538 suggest adjusting for this based around the difference in pre game Elo between the two teams. 

$$ Adjustment = \frac{2.2}{WinnerEloDiff*0.001+2.2}$$
Let's continue to say that $A$'s pre game Elo rating is 100 and $B$'s is 50. We'll keep $V$ at 200 and $K$ at 10, as before. But let's now say that $A$ lost the match by 7 points in the game. This makes the margin of victory multiplier:

$$M = log(7+1)*\frac{2.2}{-50*0.001+2.2} \approx 2.13$$

Which we then plug in for M in their updated rating formula, which becomes:

$$R'_A = 100 + 2.13*10*(0 - 0.64) \approx 87.01$$
If $A$ had only lost by one point, the margin of victory multiplier would decrease:

$$M = log(1+1)*\frac{2.2}{-50*0.001+2.2} \approx 0.709 $$

and $A$'s updated rating would become:

$$R'_A = 100 + 0.709*10*(0 - 0.64) \approx 95.46$$
Functionally, this means that the margin of victory multiplier will kick in more depending on whether you're the pre game favorite or not. This means if you win by a lot as the favorite, you won't necessarily pick up more points, but if you lose by a lot as the favorite you can take a serious hit to your points.

Here's what $A$'s updated rating would look like as a function of the margin of victory for the winner in the event of a win or a loss.

```{r update rating function, echo=T}

update_team_rating <- function(team_rating,
                               opponent_rating,
                               observed_score,
                               winner_mov,
                               expected_score,
                               k_factor = 10) {
        
        if (observed_score == 1) {
                mov_multi = log(winner_mov+1) * (2.2 / (((team_rating - opponent_rating)*0.001) + 2.2))
        } else if (observed_score ==0) {
                mov_multi = log(winner_mov+1) * (2.2 / (((opponent_rating - team_rating)*0.001) + 2.2))
        } else {
                 mov_multi = 2.2*log(2)
        }
        
        # multiplier for margin of victory

         # now compute updated rating taking into account initial rating and mov
         updated_rating = 
                 team_rating + 
                 (mov_multi *
                          k_factor * 
                          (observed_score - expected_score))
         
         return(updated_rating)
         
}

mov = seq(1, 50)
outcome = c(0,1)
a = 100
b = 50
v = 200

win_mov = foreach(i = 1:length(mov),
                  .combine = bind_rows) %:%
        foreach(j = 1:length(outcome),
                .combine = bind_rows) %do% {
                          
                           a_update = update_team_rating(
                                   team_rating = a,
                                   opponent_rating = b,
                                   observed_score  = outcome[j],
                                   winner_mov = mov[i],
                                   expected_score = get_expected_score(a, b, v),
                                   k_factor = 10) %>%
                                   tibble(updated_rating = .,
                                          team = 'A',
                                          outcome = outcome[j],
                                          mov = mov[i])
                           
                           b_update = update_team_rating(
                                   team_rating = b,
                                   opponent_rating = a,
                                   observed_score  = outcome[j],
                                   winner_mov = mov[i],
                                   expected_score = get_expected_score(b, a, v),
                                   k_factor = 10) %>%
                                   tibble(updated_rating = .,
                                          team = 'B',
                                          outcome = outcome[j],
                                          mov = mov[i])
                           
                           bind_rows(a_update, b_update)

}

# look at A's updated rating as a function of the margin of victory
win_mov %>%
        mutate(outcome = case_when(outcome == 0 & team=='A' ~ 'B win',
                                   outcome == 1 & team == 'B' ~ 'B win',
                                   outcome == 0 & team == 'B' ~ 'A win',
                                   outcome == 1 & team == 'A' ~ 'A win')) %>%
        mutate(mov = case_when(outcome == 'B win' ~ -mov,
                               outcome == 'A win' ~ mov)) %>%
        ggplot(., aes(x=mov,
                      color = team,
                      y=updated_rating))+
        geom_line()+
        theme_phil()+
        geom_hline(yintercept = 100,
                   color = 'red',
                   linetype = 'dashed')+
        xlab("Score A - Score B")+
        ylab("Updated Elo Rating")+
        scale_color_manual(values = c("red", "blue"))+
                geom_hline(yintercept = 50,
                   color = 'blue',
                   linetype = 'dashed')

```

If $A$, the pre game favorite, wins by 50, the most they can really move up is 10 points (in this case, the K factor). If $A$ loses by 50 as the favorite, they can drop nearly 25. 

What's with the constants of 2.2 and 0.001? As far as I can tell, this is because they initialized their ratings for teams at around 1500 (others have less) and they expect the maximum difference in Elo to be no greater than 2200 (2.2 / 0.001). The equation itself no longer works if the WinnerEloDiff is -2200, as the denominator goes to zero. The decision for these constants should then depend on the scale factor and the initial ratings selected.

# Elo Ratings and Historical CFB Games

## Initial Settings: 1970-1990

Okay, so at this point we have what we need in order to build out Elo Ratings for college football games. We could start this analysis going back all the way to 1869 as the starting point, but I'll start at 1970 for now since I'm at least somewhat familiar with teams in this era and will be able to eyeball the results.

I'll set every team FBS's initial rating to 1500, non FBS teams to 1200, and the scaling factor to 400. The appropriate value for K is something that I'll want to explore empirically, but I'll start it at 25 and go from there. 

Let's run from 1970 to 1990 to see how the results change each team's Elo rating over the course of a decade.

```{r look at all teams in games from 1950}

# get universe of games
games_data = games_data_raw %>%
        filter(SEASON >=1970 & SEASON <=1990) %>%
        select(GAME_ID, SEASON, WEEK, VENUE, HOME_TEAM, AWAY_TEAM, HOME_CONFERENCE, AWAY_CONFERENCE, HOME_POINTS, AWAY_POINTS, NEUTRAL_SITE) %>%
        mutate(OUTCOME = case_when(HOME_POINTS > AWAY_POINTS ~ 1,
                                   HOME_POINTS == AWAY_POINTS ~ 0.5,
                                   HOME_POINTS < AWAY_POINTS ~ 0)) %>%
        arrange(SEASON, WEEK, GAME_ID)

# now get this at the team level
team_games = games_data %>%
        select(SEASON, GAME_ID, WEEK, HOME_TEAM, HOME_CONFERENCE) %>%
        rename(TEAM = HOME_TEAM,
               CONFERENCE = HOME_CONFERENCE) %>%
        bind_rows(., games_data %>%
                          select(SEASON, GAME_ID, WEEK, AWAY_TEAM, AWAY_CONFERENCE) %>%
                          rename(TEAM = AWAY_TEAM,
                                 CONFERENCE = AWAY_CONFERENCE)) %>%
        arrange(SEASON, WEEK, GAME_ID)

```

This means we loop over every game, look at the result, and then update each team's Elo rating based on the outcome and the margin of victory. 

```{r loop over games to get updated elo ratings, include=F}

# set the initial ratings for the first game for every team
initial_team_elo_ratings = team_games %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        group_by(TEAM) %>%
        filter(SEASON == min(SEASON)) %>%
        filter(WEEK == min(WEEK)) %>%
        ungroup() %>%
        mutate(TYPE = "Pre_Elo") %>%
        mutate(TEAM_ELO = case_when(!is.na(CONFERENCE) ~ 1500,
                                    TRUE ~ 1200)) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO, CONFERENCE)

# make a copy, this will be the one we update
team_elo_ratings = initial_team_elo_ratings

# game ids
game_ids = games_data %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        select(GAME_ID) %>%
        unique() %>%
        pull(GAME_ID)

# specify parameters
k = 25
v = 400

# loop over games
elo_game_results = foreach (i = 1:length(game_ids), .combine = bind_rows) %do% {
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                                           filter(GAME_ID == game_ids[i]) %>%
                                           filter(TEAM == away_team) %>%
                                           filter(TYPE == 'Pre_Elo') %>%
                                           pull(TEAM_ELO)
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                home_expected_score = get_expected_score(home_team_pre_elo,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo, 
                                                         V = v)
                
                ## now look at the outcome
                # get the outcome
                home_team_outcome = games_data %>% 
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(OUTCOME)
                
                # get the margin of victory for the winner
                winner_margin = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        mutate(WIN_MARGIN = abs(HOME_POINTS-AWAY_POINTS)) %>%
                        pull(WIN_MARGIN)
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating(home_team_pre_elo,
                                                        home_team_outcome,
                                                        home_expected_score,
                                                        winner_margin,
                                                        k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating(away_team_pre_elo,
                                                        1-home_team_outcome,
                                                        away_expected_score,
                                                        winner_margin,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  games_data %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON),
                               WEEK =  games_data %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                         SEASON =  games_data %>%
                                              filter(GAME_ID == game_ids[i]) %>%
                                              pull(SEASON),
                        WEEK =  games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_POINTS = games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(HOME_POINTS),
                        AWAY_POINTS = games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(AWAY_POINTS),
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome) %>%
                        mutate(K = k,
                               V = v)
                
                game_result

}

```

### SEC 

Once that finishes, we have the accumulation of Elo ratings as a function of game outcomes over the selected time period. For instance, here is each SEC team's Elo ratings fared from 1970-1980.

```{r get initial and updated for SEC v1}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'SEC') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### Big Ten

```{r get initial and updated for big 10 v1}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'Big Ten') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### SWC

```{r get initial and updated for southwest v1}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'Southwest') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### Results

We can then look at the log loss over the course of each season. Using the expected score from the Elo ratings, how do we perform in predicting the outcomes of games? I'll compare the result of the Elo ratings to a baseline model that assigns the home team a 60% chance of winning. 

```{r log loss by week by season}

int_breaks <- function(x, n = 5) {
  l <- pretty(x, n)
  l[abs(l %% 1) < .Machine$double.eps ^ 0.5] 
}

# log loss by game 
# elo_game_results %>%
#         mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
#                                        TRUE ~'no'))) %>%
#         group_by(SEASON, WEEK) %>%
#         mutate(games = n_distinct(GAME_ID)) %>%
#         group_by(SEASON, WEEK, games) %>%
#         mn_log_loss(truth = HOME_WIN,
#                     estimate = HOME_PROB,
#                     event_level = 'second') %>%
#         mutate(Model = 'Elo') %>%
#         bind_rows(.,
#                   elo_game_results %>%
#                           mutate(HOME_PROB = .6) %>%
#                           mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
#                                                              TRUE ~'no'))) %>%
#                           group_by(SEASON, WEEK) %>%
#                           mutate(games = n_distinct(GAME_ID)) %>%
#                           group_by(SEASON, WEEK, games) %>%
#                           mn_log_loss(truth = HOME_WIN,
#                                     estimate = HOME_PROB,
#                                     event_level = 'second') %>%
#                           mutate(Model = 'Home Win')
#                   ) %>%
#         ggplot(., aes(x=WEEK,
#                       color = Model,
#                       y=.estimate,
#                       size = games))+
#         geom_point()+
#         geom_line(lwd = 1,
#                   stat = 'smooth',
#                   method = 'loess',
#                   formula = 'y ~ x',
#                   span = 0.25)+
#         theme_phil()+
#         theme(legend.title = element_text())+
#         guides(size = guide_legend(title = 'Number of Games',
#                                    title.position = 'top'),
#                color = guide_legend(title.position = 'top'))+
#             scale_x_continuous(breaks = int_breaks)+
#         ylab("log-loss")+
#         scale_color_manual(values = c("deepskyblue1",
#                                       "grey40"))+
#         ggtitle("Average Log-Loss by Season")+
#         coord_cartesian(ylim = c(0, 1))+
#         facet_wrap(SEASON ~.,
#                    ncol = 4)

# log loss
elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        mn_log_loss(truth = HOME_WIN,
                    estimate = HOME_PROB,
                    event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        bind_rows(.,
                  elo_game_results %>%
                          mutate(HOME_PROB = .6) %>%
                          mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                                             TRUE ~'no'))) %>%
                          group_by(SEASON) %>%
                          mutate(games = n_distinct(GAME_ID)) %>%
                          group_by(SEASON, games) %>%
                          mn_log_loss(truth = HOME_WIN,
                                    estimate = HOME_PROB,
                                    event_level = 'second') %>%
                          mutate(Model = 'Home Win')
                  ) %>%
        ggplot(., aes(x=SEASON,
                      color = Model,
                      y=.estimate,
                      size = games))+
        geom_point()+
        geom_line(lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.2)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("log-loss")+
        scale_color_manual(values = c("deepskyblue1",
                                      "grey40"))+
        ggtitle("Average Log-Loss by Season")+
        coord_cartesian(ylim = c(0, 1))

```

As we would hope, the Elo ratings outperform simply predicting that the home team will win.

We can also just look at the number of games correctly predicted, and find similar results.

```{r by each}

# log loss
elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        yardstick::accuracy(truth = HOME_WIN,
                            estimate = HOME_PRED,
                            event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        bind_rows(.,
                  elo_game_results %>%
                          mutate(HOME_PRED = factor('yes',
                                                    levels = c("no", "yes"))) %>%
                          mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                                             TRUE ~'no'))) %>%
                          group_by(SEASON) %>%
                          mutate(games = n_distinct(GAME_ID)) %>%
                          group_by(SEASON, games) %>%
                          yardstick::accuracy(truth = HOME_WIN,
                                    estimate = HOME_PRED,
                                    event_level = 'second') %>%
                          mutate(Model = 'Home Win')
                  ) %>%
        ggplot(., aes(x=SEASON,
                      color = Model,
                      y=.estimate,
                      size = games))+
        geom_point()+
        geom_line(lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Accuracy")+
        scale_color_manual(values = c("deepskyblue1",
                                      "grey40"))+
        ggtitle("Average Accuracy by Season")+
        coord_cartesian(ylim = c(0, 1))

```

Similarly, log loss by week of each season. The current Elo approach tends to be weaker at the beginning of each season - more on this in a bit.

```{r log loss by week}

elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(WEEK) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(WEEK, games) %>%
        yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        bind_rows(.,
                  elo_game_results %>%
                          mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
                          mutate(HOME_PROB = .6) %>%
                          group_by(WEEK) %>%
                          mutate(games = n_distinct(GAME_ID)) %>%
                          group_by(WEEK, games) %>%
                          yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
                          mutate(Model = 'Home Win'),
                  )  %>%
        ggplot(., aes(x=WEEK,
                      y=.estimate))+
        geom_point(aes(color = Model,
                       size = games))+
        geom_line(aes(color = Model),
                  lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.2)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Log Loss")+
        scale_color_manual(values = c("deepskyblue1",
                                      "grey40"))+
        ggtitle("Average Log-Loss by Week")+
        coord_cartesian(ylim = c(0, 1))

```

### Point Spread

A nice feature of the Elo rating framework is that it also extends to predicting the point differential. Here is home team's scoring margin (Home Points - Away Points) as a function of the home team's Elo diff (Home Pre Elo - Away Pre Elo).

```{r we can also look at the predicted spread vs the actual}

elo_game_results %>%
        mutate(HOME_ELO_DIFF = HOME_PRE_ELO - AWAY_PRE_ELO) %>% 
  #      mutate(HOME_PRED_SCORE_DIFF = HOME_ELO_DIFF / 25)
        mutate(HOME_SCORE_DIFF = HOME_POINTS-AWAY_POINTS) %>% 
        ggplot(., aes(x=HOME_ELO_DIFF, y=HOME_SCORE_DIFF))+
        geom_point()+
        facet_wrap(SEASON ~., ncol =6) + 
        theme_phil()+
        geom_vline(xintercept =0,
                   linetype = 'dotted')+
        geom_hline(yintercept =0,
                   linetype = 'dotted')+
        geom_smooth(method = 'lm',
                    formula = 'y ~ x')+
        ggtitle("Predicted Point Spread via Pre Game Elo Scores")

```

The relationship changes over the years, as the initial few seasons are being used to learn the Elo scores, but once we have a few seasons worth of data the partial effect of a point change in Elo differential on the score differential seems to be around .04.

```{r predicted margin}

pre_elo_diffs = tibble(HOME_PRE_ELO_DIFF = seq(-500, 500, 5))

# fit a linear model of the point differential on the elo ratings
foo = elo_game_results %>%
        mutate(HOME_PRE_ELO_DIFF = HOME_PRE_ELO - AWAY_PRE_ELO) %>% 
        #mutate(HOME_PRED_SCORE_DIFF = HOME_ELO_DIFF / 25)
        mutate(HOME_SCORE_DIFF = HOME_POINTS-AWAY_POINTS) %>% 
        nest(-SEASON) %>%
        mutate(lm = map(data, 
                        ~ lm(HOME_SCORE_DIFF ~ HOME_PRE_ELO_DIFF,
                             data = .x))) %>%
        mutate(tidied = map(lm, tidy, se="robust", conf.int=T)) %>%
        mutate(pred = map(lm, ~ .x %>% predict(pre_elo_diffs,
                                        interval = 'prediction') %>%
                                  bind_cols(., pre_elo_diffs))) %>%
        mutate(confidence = map(lm, ~ .x %>% predict(pre_elo_diffs,
                                        interval = 'confidence') %>%
                                  bind_cols(., pre_elo_diffs)))

# coef
foo %>%
        select(SEASON, tidied) %>%
        unnest() %>%
        filter(term == 'HOME_PRE_ELO_DIFF') %>%
        ggplot(., aes(x=SEASON,
                      y=estimate,
                      ymin = conf.low,
                      ymax = conf.high))+
        geom_point()+
        geom_pointrange()+
        theme_phil()+
        coord_cartesian(ylim = c(0, NA))+
        geom_hline(yintercept = 0,
                   linetype = 'dashed')+
        geom_hline(yintercept = 0.04,
                   linetype = 'dotted',
                   color ='grey60')

# # predicted spread
# foo %>%
#         select(SEASON, pred) %>%
#         unnest() %>%
#         mutate(interval = 'prediction') %>%
#         bind_rows(.,
#                   foo %>%
#                           select(SEASON, confidence) %>%
#                           unnest() %>%
#                           mutate(interval = 'confidence')) %>%
#         filter(HOME_PRE_ELO_DIFF == 100) %>%
#         mutate(type = 'Home Elo - Away Elo = 100') %>%
#    #     filter(HOME_PRE_ELO_DIFF == 500)
#         ggplot(., aes(x=SEASON,
#                       y=fit,
#                       fill = interval,
#                       color = interval,
#                       ymin = lwr,
#                       ymax = upr))+
#         geom_line()+
#         geom_ribbon(alpha = 0.5)+
#         theme_phil()+
#         facet_wrap(type ~.)+
#         geom_hline(yintercept = 0,
#                    linetype = 'dashed')

```

We can simulate the point differential and compare it to the actual. I'll look at the 1980 season, week by week to see simulated vs actual.

```{r simulte and compare}

set.seed(1999)
foo %>% 
        filter(SEASON == 1980) %>%
        mutate(sim = map(lm, simulate)) %>% 
        select(SEASON, data, sim) %>% 
        unnest() %>% 
        mutate(sim_1 = round(sim_1, 0)) %>%
        mutate(HOME_SCORE_DIFF_char = case_when(HOME_SCORE_DIFF > 0 ~ paste("+", HOME_SCORE_DIFF, sep=""),
                                    HOME_SCORE_DIFF == 0 ~ paste("Tie"),
                                    HOME_SCORE_DIFF < 0 ~ paste(HOME_SCORE_DIFF, sep=""))) %>%
        mutate(sim_char = case_when(sim_1 > 0 ~ paste("+", sim_1, sep=""),
                                    sim_1 == 0 ~ paste("Tie"),
                                    sim_1 < 0 ~ paste(sim_1, sep="")),
               GAME = paste(HOME_TEAM, " ", AWAY_TEAM, "\n",
                            "Actual.:", HOME_TEAM,  HOME_SCORE_DIFF_char, "\n",
                            "Sim:", HOME_TEAM, sim_char, sep="")) %>%
        mutate(CORRECT = case_when(sim_1 >0 & HOME_SCORE_DIFF >0 ~ 'yes',
                                   sim_1 <0 & HOME_SCORE_DIFF <0 ~ 'yes',
                                   TRUE ~ 'no')) %>%
        ggplot(., aes(x=HOME_SCORE_DIFF,
                      color = CORRECT,
                      label = GAME,
                      y=sim_1))+geom_point()+
        geom_text(check_overlap=T, 
                  vjust=-0.5, size=2)+
        theme_phil()+
        scale_color_manual(values = c("red", "blue"))+
        facet_wrap(SEASON + WEEK~.,
                   ncol = 4)+
        geom_vline(xintercept =0,
                   linetype = 'dotted')+
        geom_hline(yintercept = 0,
                   linetype = 'dotted')

```

I'll save the Elo ratings computed with these settings so we can see how they compare with changes to the parameters/methodology.

```{r save v1 results}

elo_game_results_v1 = elo_game_results %>%
        mutate(K = k,
               V = v,
               Reversion = F)

team_elo_ratings_v1 = team_elo_ratings %>%
        mutate(K = k,
               V = v,
               Reversion = F)

rm(team_elo_ratings,
   elo_game_results)

```



## Initial Settings with Mean Reversion

As it's constructed so far, the Elo ratings for a team in one season pick up right from where they left off in the previous season. This is particularly an issue in the world college football, given that players graduate and turnover in rosters year over year is high. We shouldn't expect, in other words, a team at the beginning of its 1980 season to be the exact same as it ended its 1979 season.

Currently, our Elo ratings do not reset in anyway, and this means we ended up being a little bit worse at the beginning of each season.

```{r show results by week by season}

elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(SEASON, WEEK) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, WEEK, games) %>%
        yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
        mutate(Model = 'Elo') %>%
        ggplot(., aes(x=WEEK,
                      by = SEASON,
                      y=.estimate))+
        geom_point(aes(size = games),
                   alpha = 0.5,
                   color = 'deepskyblue1')+
        geom_smooth(
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x')+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Log Loss")+
        # scale_color_manual(values = c("deepskyblue1",
        #                               "grey40"))+
        ggtitle("Average Log-Loss by Week")+
        coord_cartesian(ylim = c(0, 1))

```

We can handle this by regressing each team back to the mean at the start of each season. I'll apply a 1/3 weight back to 1500 for FBS teams and a 1/3 weight back to 1200 for non FBS teams between seasons.

```{r re run elo ratings with mean reversion}

# set the initial ratings for the first game for every team
initial_team_elo_ratings = team_games %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        group_by(TEAM) %>%
        filter(SEASON == min(SEASON)) %>%
        filter(WEEK == min(WEEK)) %>%
        ungroup() %>%
        mutate(TYPE = "Pre_Elo") %>%
        mutate(TEAM_ELO = case_when(!is.na(CONFERENCE) ~ 1500,
                                    TRUE ~ 1200)) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO, CONFERENCE)

# make a copy, this will be the one we update
team_elo_ratings = initial_team_elo_ratings

# game ids
game_ids = games_data %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        select(GAME_ID) %>%
        unique() %>%
        pull(GAME_ID)

# specify parameters
k = 25
v = 400

# run 
elo_game_results = foreach (i = 1:length(game_ids), .combine = bind_rows) %do% {
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                                           filter(GAME_ID == game_ids[i]) %>%
                                           filter(TEAM == away_team) %>%
                                           filter(TYPE == 'Pre_Elo') %>%
                                           pull(TEAM_ELO)
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                home_expected_score = get_expected_score(home_team_pre_elo,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo, 
                                                         V = v)
                
                ## now look at the outcome
                # get the outcome
                home_team_outcome = games_data %>% 
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(OUTCOME)
                
                # get the margin of victory for the winner
                winner_margin = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        mutate(WIN_MARGIN = abs(HOME_POINTS-AWAY_POINTS)) %>%
                        pull(WIN_MARGIN)
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating(home_team_pre_elo,
                                                        home_team_outcome,
                                                        home_expected_score,
                                                        winner_margin,
                                                        k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating(away_team_pre_elo,
                                                        1-home_team_outcome,
                                                        away_expected_score,
                                                        winner_margin,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  games_data %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON),
                               WEEK =  games_data %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                
                # revert new pre elo meetings to mean if new season
                new_pre_elo_ratings = new_pre_elo_ratings %>%
                        mutate(NEW_SEASON = case_when(SEASON > games_data %>% 
                                                              filter(GAME_ID == game_ids[i]) %>%
                                                              pull(SEASON) ~ T,
                                                      TRUE ~ F)) %>%
                        mutate(TEAM_ELO = case_when(
                                (NEW_SEASON == T & is.na(CONFERENCE)) ~ (1/3)*1200 + (2/3)*TEAM_ELO,
                                (NEW_SEASON == T & !is.na(CONFERENCE)) ~ (1/3)*1500 + (2/3)*TEAM_ELO,
                               TRUE ~ TEAM_ELO))
                                                              
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                         SEASON =  games_data %>%
                                              filter(GAME_ID == game_ids[i]) %>%
                                              pull(SEASON),
                        WEEK =  games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_POINTS = games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(HOME_POINTS),
                        AWAY_POINTS = games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(AWAY_POINTS),
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome) %>%
                        mutate(K = k,
                               V = v)
                
                game_result

}

```

### SEC

```{r now plot SEC with mena reversion}

max_game = team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>% 
        ungroup() %>%
        summarize(max_game = max(GAME)) %>%
        pull(max_game)

team_elo_ratings %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO) %>%
        spread(TYPE, TEAM_ELO) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, Pre_Elo, Post_Elo) %>%
        group_by(TEAM, SEASON) %>%
        mutate(GAME = row_number()) %>%
        left_join(., team_games %>%
                          select(SEASON, GAME_ID, WEEK, TEAM, CONFERENCE),
                  by = c("SEASON", "GAME_ID", "WEEK", "TEAM")) %>%
        filter(CONFERENCE == 'SEC') %>%
        group_by(SEASON, TEAM) %>%
        mutate(LAST_GAME = GAME == max(GAME)) %>%
        mutate(TEAM_LABEL = case_when(LAST_GAME == T ~ TEAM)) %>%
        ggplot(., aes(x=GAME,
                      label = TEAM_LABEL,
                      color = TEAM,
                      y=Post_Elo))+
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
        ) +
       # geom_point()+
        geom_line(lwd = 1.1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.25)+
        facet_wrap(CONFERENCE + SEASON~.,
                   ncol = 6)+
        theme_phil()+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, max_game+1))

```

### Compare Mean Reverting to Initial Ratings

I'll now compare the unadjusted ratings to the updated ratings that include mean reversion. The difference is very slight, and its entirely possible that it's not significant, but we do see slightly better results as the seasons wear on using a beginning of season adjustment. I could do like, a Wald test, to compare the two formally, but who has time for that.

```{r compare log loss between versions}

# log loss
elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        mn_log_loss(truth = HOME_WIN,
                    estimate = HOME_PROB,
                    event_level = 'second') %>%
        mutate(Model = 'Elo Mean Reversion') %>%
        bind_rows(
                elo_game_results_v1 %>%
                        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        group_by(SEASON) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, games) %>%
        mn_log_loss(truth = HOME_WIN,
                    estimate = HOME_PROB,
                    event_level = 'second') %>%
        mutate(Model = 'Elo')) %>%
        ggplot(., aes(x=SEASON,
                      color = Model,
                      y=.estimate,
                      size = games))+
        geom_point()+
        geom_line(lwd = 1,
                  stat = 'smooth',
                  method = 'loess',
                  formula = 'y ~ x',
                  span = 0.2)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("log-loss")+
        scale_color_manual(values = c("deepskyblue1",
                                      "navy"))+
        ggtitle("Average Log-Loss by Season")+
        coord_cartesian(ylim = c(0, 1))

```

Looking at the results week by week, we see a slight gain to the early weeks in the season.

```{r show results by week by season with updated version}

elo_game_results %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                       TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                     TRUE ~ 'no'),
                                  levels = c("no", "yes"))) %>%
        group_by(SEASON, WEEK) %>%
        mutate(games = n_distinct(GAME_ID)) %>%
        group_by(SEASON, WEEK, games) %>%
        yardstick::mn_log_loss(truth = HOME_WIN,
                            estimate = HOME_PROB,
                            event_level = 'second') %>%
        mutate(Model = 'Elo Mean Reversion') %>%
        bind_rows(.,
                elo_game_results_v1 %>%
                mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
                mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
                group_by(SEASON, WEEK) %>%
                mutate(games = n_distinct(GAME_ID)) %>%
                group_by(SEASON, WEEK, games) %>%
                yardstick::mn_log_loss(truth = HOME_WIN,
                                    estimate = HOME_PROB,
                                    event_level = 'second') %>%
                mutate(Model = 'Elo')) %>%
        ggplot(., aes(x=WEEK,
                      group = Model,
                      color = Model,
                      by = SEASON,
                      y=.estimate))+
        geom_point(aes(size = games),
                   alpha = 0.5)+
        geom_smooth(
                  stat = 'smooth',
                  method = 'loess',
                  se=F,
                  formula = 'y ~ x')+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title = 'Number of Games',
                                   title.position = 'top'),
               color = guide_legend(title.position = 'top'))+
            scale_x_continuous(breaks = int_breaks)+
        ylab("Log Loss")+
         scale_color_manual(values = c("deepskyblue1",
                                       "navy"))+
        ggtitle("Average Log-Loss by Week")+
        coord_cartesian(ylim = c(0, 1))

```

```{r save v2}

elo_game_results_v2 = elo_game_results %>%
        mutate(K = k,
               V = v,
               Reversion = T)

team_elo_ratings_v2 = team_elo_ratings %>%
        mutate(K = k,
               V = v,
               Reversion = T)

rm(team_elo_ratings,
   elo_game_results)

```

### Home Team Advantage

I've seen other Elo rating systems explicitly add points to teams that are at home as a means of accounting for home field advantage. Right now, I'm not doing that, so we should expect to see the home team outperform their Elo rating. Is that the case? I'll look at the performance of the predictions from each of the models so far.

```{r results by home team}

class_metrics = metric_set(yardstick::precision,
                           yardstick::recall,
                           yardstick::f_meas,
                           yardstick::accuracy,
                           yardstick::bal_accuracy,
                           yardstick::kap,
                           yardstick::npv,
                           yardstick::ppv)

elo_game_results_v1 %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        yardstick::conf_mat(HOME_WIN, HOME_PRED, dnn = c("Home Pred", "Home Win"))

elo_game_results_v2 %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        yardstick::conf_mat(HOME_WIN, HOME_PRED, dnn = c("Home Pred", "Home Win"))


# bind together
bind_rows(
elo_game_results_v1 %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        mutate(Model = 'Elo'),
elo_game_results_v2 %>%
        select(SEASON, WEEK, GAME_ID, HOME_TEAM, AWAY_TEAM, HOME_PROB, AWAY_PROB, HOME_OUTCOME, K, V) %>%
        mutate(HOME_WIN = factor(case_when(HOME_OUTCOME == 1 ~ 'yes',
                                               TRUE ~'no'))) %>%
        mutate(HOME_PRED = factor(case_when(HOME_PROB > AWAY_PROB ~ 'yes',
                                             TRUE ~ 'no'),
                                          levels = c("no", "yes"))) %>%
        mutate(Model = 'Elo Mean Reversion')) %>%
        group_by(Model, K, V) %>%
        class_metrics(truth = HOME_WIN,
                      estimate = HOME_PRED) %>%
        mutate_if(is.numeric, round, 3) %>%
        flextable() %>%
        autofit()

```

The Elo ratings with mean reversion at the beginning of each season are generally better across the board, but both versions tend to do better when predicting that the home team will win (PPV). When the models predict that the home team will lose, they don't do as well (NPV). Home teams win slightly more than we would expect.

I'll add a temporary 50 point bump for the home team, as this roughly maps to a 5% increase in the probabiltiy of winning. I won't add any bonus for games played at neutral sites. I'll now re run making this amendment.

```{r remove v2}

rm(elo_game_results,
   team_elo_ratings)

```


```{r run v3}

# set the initial ratings for the first game for every team
initial_team_elo_ratings = team_games %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        group_by(TEAM) %>%
        filter(SEASON == min(SEASON)) %>%
        filter(WEEK == min(WEEK)) %>%
        ungroup() %>%
        mutate(TYPE = "Pre_Elo") %>%
        mutate(TEAM_ELO = case_when(!is.na(CONFERENCE) ~ 1500,
                                    TRUE ~ 1200)) %>%
        select(SEASON, GAME_ID, WEEK, TEAM, TYPE, TEAM_ELO, CONFERENCE)

# make a copy, this will be the one we update
team_elo_ratings = initial_team_elo_ratings

# game ids
game_ids = games_data %>%
        arrange(SEASON, WEEK, GAME_ID) %>%
        select(GAME_ID) %>%
        unique() %>%
        pull(GAME_ID)

# specify parameters
k = 25
v = 400

# run 
elo_game_results = foreach (i = 1:length(game_ids), .combine = bind_rows) %do% {
                                   
                # now pull relevant info from the selected game
                # get the home team
                home_team = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_TEAM)
                
                # get their conference
                home_team_conference = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(HOME_CONFERENCE)
                
                # get the away team
                away_team = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_TEAM)
                
                # get their conference
                away_team_conference = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(AWAY_CONFERENCE)
                
                # is the game at a non neutral site?
                neutral_site = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(NEUTRAL_SITE)
                
                # if not played at a neutral site, then bump the home team's score up in setting the pre game score
                if (neutral_site == F) {home_team_adjust = 50} else {home_team_adjust = 0}
                                   
                # get home elo rating for that game
                home_team_pre_elo = team_elo_ratings %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        filter(TEAM == home_team) %>%
                        filter(TYPE == 'Pre_Elo') %>%
                        pull(TEAM_ELO)
                                         
                # get away elo rating
                away_team_pre_elo = team_elo_ratings %>%
                                           filter(GAME_ID == game_ids[i]) %>%
                                           filter(TEAM == away_team) %>%
                                           filter(TYPE == 'Pre_Elo') %>%
                                           pull(TEAM_ELO)
        
                ### get each opponent's expected score based on their pre game elo rating
                # home expected score
                # add in a 50 point bump here fpr the home team
                home_expected_score = get_expected_score(home_team_pre_elo+home_team_adjust,
                                                         away_team_pre_elo,
                                                         V = v)
                
                # away expected score
                # add in a 50 point bump for the home team
                away_expected_score = get_expected_score(away_team_pre_elo,
                                                         home_team_pre_elo+home_team_adjust, 
                                                         V = v)
                
                ## now look at the outcome
                # get the outcome
                home_team_outcome = games_data %>% 
                        filter(GAME_ID == game_ids[i]) %>%
                        pull(OUTCOME)
                
                # get the margin of victory for the winner
                winner_margin = games_data %>%
                        filter(GAME_ID == game_ids[i]) %>%
                        mutate(WIN_MARGIN = abs(HOME_POINTS-AWAY_POINTS)) %>%
                        pull(WIN_MARGIN)
                
                ### update team rating based on pre game elo, outcome, and expected score
                # home team update
                home_team_post_elo = update_team_rating(home_team_pre_elo,
                                                        home_team_outcome,
                                                        home_expected_score,
                                                        winner_margin,
                                                        k_factor = k)
                
                # away team update
                away_team_post_elo = update_team_rating(away_team_pre_elo,
                                                        1-home_team_outcome,
                                                        away_expected_score,
                                                        winner_margin,
                                                        k_factor = k)
                                    
                # output each team's post game elo rating
                post_elo_ratings = 
                        tibble(SEASON =  games_data %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(SEASON),
                               WEEK =  games_data %>%
                                       filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                               GAME_ID = game_ids[i],
                               TEAM = c(home_team, away_team),
                               CONFERENCE = c(home_team_conference, away_team_conference),
                               TYPE = "Post_Elo",
                               TEAM_ELO = c(home_team_post_elo, away_team_post_elo))
                                    
                # now update each team's elo rating for the next game
                new_pre_elo_ratings = 
                        bind_rows(
                                # home team
                                tibble(SEASON =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = home_team,
                                       GAME_ID =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  team_games %>%
                                               filter(TEAM == home_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = home_team_post_elo),
                                # away team
                                tibble(SEASON =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(SEASON),
                                       WEEK =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(WEEK),
                                       TEAM = away_team,
                                       GAME_ID =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(GAME_ID),
                                       CONFERENCE =  team_games %>%
                                               filter(TEAM == away_team) %>%
                                               mutate(CURRENT = GAME_ID == game_ids[i]) %>%
                                               filter(lag(CURRENT, 1)==T) %>%
                                               pull(CONFERENCE),
                                       TYPE = 'Pre_Elo',
                                       TEAM_ELO = away_team_post_elo))
                
                
                # revert new pre elo meetings to mean if new season
                new_pre_elo_ratings = new_pre_elo_ratings %>%
                        mutate(NEW_SEASON = case_when(SEASON > games_data %>% 
                                                              filter(GAME_ID == game_ids[i]) %>%
                                                              pull(SEASON) ~ T,
                                                      TRUE ~ F)) %>%
                        mutate(TEAM_ELO = case_when(
                                (NEW_SEASON == T & is.na(CONFERENCE)) ~ (1/3)*1200 + (2/3)*TEAM_ELO,
                                (NEW_SEASON == T & !is.na(CONFERENCE)) ~ (1/3)*1500 + (2/3)*TEAM_ELO,
                               TRUE ~ TEAM_ELO))
                                                              
                 # add post game elo and new pre game elo back in
                team_elo_ratings = 
                        team_elo_ratings %>%
                        bind_rows(.,
                                  post_elo_ratings) %>%
                        bind_rows(., 
                                  new_pre_elo_ratings)
                
                # output
                 cat("\r", i, "of", length(game_ids), "games completed");  flush.console()
                 
                 # return the outcome to be stored from the loop
                game_result = tibble(
                         SEASON =  games_data %>%
                                              filter(GAME_ID == game_ids[i]) %>%
                                              pull(SEASON),
                        WEEK =  games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                       pull(WEEK),
                        GAME_ID = game_ids[i],
                        HOME_TEAM = home_team,
                        AWAY_TEAM = away_team,
                        HOME_CONFERENCE = home_team_conference,
                        AWAY_CONFERENCE = away_team_conference,
                        HOME_POINTS = games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(HOME_POINTS),
                        AWAY_POINTS = games_data %>%
                                filter(GAME_ID == game_ids[i]) %>%
                                pull(AWAY_POINTS),
                        HOME_PROB = home_expected_score,
                        AWAY_PROB = away_expected_score,
                        HOME_PRE_ELO = home_team_pre_elo,
                        HOME_POST_ELO = home_team_post_elo,
                        AWAY_PRE_ELO = away_team_pre_elo,
                        AWAY_POST_ELO = away_team_post_elo,
                        HOME_OUTCOME = home_team_outcome,
                        NEUTRAL_SITE = neutral_site) %>%
                        mutate(K = k,
                               V = v)
                
                game_result

}

```


```


Okay, so at this point we have everything we need to try out simulating an entire season.

I'm going to simulate the 